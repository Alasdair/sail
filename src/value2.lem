(*========================================================================*)
(*     Sail                                                               *)
(*                                                                        *)
(*  Copyright (c) 2013-2017                                               *)
(*    Kathyrn Gray                                                        *)
(*    Shaked Flur                                                         *)
(*    Stephen Kell                                                        *)
(*    Gabriel Kerneis                                                     *)
(*    Robert Norton-Wright                                                *)
(*    Christopher Pulte                                                   *)
(*    Peter Sewell                                                        *)
(*    Alasdair Armstrong                                                  *)
(*    Brian Campbell                                                      *)
(*    Thomas Bauereiss                                                    *)
(*    Anthony Fox                                                         *)
(*    Jon French                                                          *)
(*    Dominic Mulligan                                                    *)
(*    Stephen Kell                                                        *)
(*    Mark Wassell                                                        *)
(*                                                                        *)
(*  All rights reserved.                                                  *)
(*                                                                        *)
(*  This software was developed by the University of Cambridge Computer   *)
(*  Laboratory as part of the Rigorous Engineering of Mainstream Systems  *)
(*  (REMS) project, funded by EPSRC grant EP/K008528/1.                   *)
(*                                                                        *)
(*  Redistribution and use in source and binary forms, with or without    *)
(*  modification, are permitted provided that the following conditions    *)
(*  are met:                                                              *)
(*  1. Redistributions of source code must retain the above copyright     *)
(*     notice, this list of conditions and the following disclaimer.      *)
(*  2. Redistributions in binary form must reproduce the above copyright  *)
(*     notice, this list of conditions and the following disclaimer in    *)
(*     the documentation and/or other materials provided with the         *)
(*     distribution.                                                      *)
(*                                                                        *)
(*  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''    *)
(*  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED     *)
(*  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A       *)
(*  PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR   *)
(*  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,          *)
(*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT      *)
(*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF      *)
(*  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND   *)
(*  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,    *)
(*  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT    *)
(*  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF    *)
(*  SUCH DAMAGE.                                                          *)
(*========================================================================*)

open import Pervasives

open import Sail2_values
open import Sail2_operators_bitlists

open import Regex

type vl =
  | VL_bits of list bitU * bool
  | VL_bit of bitU
  | VL_bool of bool
  | VL_unit
  | VL_int of integer
  | VL_string of string
  | VL_regex of regex
  | VL_real of string
  | VL_tuple of list vl
  | VL_matcher of int * int
  | VL_list of list vl
  | VL_constructor of string * vl
  | VL_enum of string
  | VL_struct of list (string * vl)
  | VL_ref of string

let mk_bits = Maybe.map (fun x -> VL_bits x true)

let primops name args =
  match (name, args) with
  (* lib/flow.sail *)
  | ("not", [VL_bool b]) -> Just (VL_bool (not b))
  | ("eq_bit", [VL_bit b1; VL_bit b2]) -> Just (VL_bool (b1 = b2))
  | ("eq_int", [VL_int n; VL_int m]) -> Just (VL_bool (n = m))
  | ("eq_bool", [VL_bool b1; VL_bool b2]) -> Just (VL_bool (b1 = b2))
  | ("eq_anything", [v1; v2]) -> Just (VL_bool (v1 = v2))
  | ("lt", [VL_int n; VL_int m]) -> Just (VL_bool (n < m))
  | ("lteq", [VL_int n; VL_int m]) -> Just (VL_bool (n <= m))
  | ("gt", [VL_int n; VL_int m]) -> Just (VL_bool (n > m))
  | ("gteq", [VL_int n; VL_int m]) -> Just (VL_bool (n >= m))
  | ("sail_cons", [v; VL_list vs]) -> Just (VL_list (v :: vs))

  (* lib/arith.sail *)
  | ("add_int", [VL_int n; VL_int m]) -> Just (VL_int (integerAdd n m))
  | ("sub_int", [VL_int n; VL_int m]) -> Just (VL_int (integerMinus n m))
  | ("mult_int", [VL_int n; VL_int m]) -> Just (VL_int (integerMult n m))
  | ("ediv_int", [VL_int n; VL_int m]) -> Just (VL_int (integerDiv n m))

  (* lib/vector_dec.sail *)
  | ("eq_bits", [VL_bits bv1 _; VL_bits bv2 _]) -> Just (VL_bool (eq_vec bv1 bv2))
  | ("not_bits", [VL_bits bv d]) -> Just (VL_bits (not_vec bv) d)
  | ("or_bits", [VL_bits bv1 d; VL_bits bv2 _]) -> Just (VL_bits (or_vec bv1 bv2) d)
  | ("and_bits", [VL_bits bv1 d; VL_bits bv2 _]) -> Just (VL_bits (and_vec bv1 bv2) d)
  | ("xor_bits", [VL_bits bv1 d; VL_bits bv2 _]) -> Just (VL_bits (xor_vec bv1 bv2) d)
  | ("sail_unsigned", [VL_bits bv _]) -> Just (VL_int (uint bv))
  | ("sail_signed", [VL_bits bv _]) -> Just (VL_int (sint bv))
  | ("zero_extend", [VL_bits bv d; VL_int n]) -> Just (VL_bits (zero_extend bv n) d)
  | ("sign_extend", [VL_bits bv d; VL_int n]) -> Just (VL_bits (sign_extend bv n) d)
  | ("zeros", [VL_int n]) -> Just (VL_bits (zeros n) true)
  | ("add_bits", [VL_bits bv1 d; VL_bits bv2 _]) -> Just (VL_bits (add_vec bv1 bv2) d)
  | ("add_bits_int", [VL_bits bv d; VL_int n]) -> Just (VL_bits (add_vec_int bv n) d)
  | ("get_slice_int", [VL_int len; VL_int n; VL_int lo]) -> Just (VL_bits (get_slice_int len n lo) true)
  | ("replicate_bits", [VL_bits bv d; VL_int n]) -> Just (VL_bits (replicate_bits bv n) d)
  | ("length", [VL_bits bv _]) -> Just (VL_int (length bv))
  | ("append", [VL_bits bv1 d; VL_bits bv2 _]) -> Just (VL_bits (concat_vec bv1 bv2) d)
  | ("vector_subrange", [VL_bits bv d; VL_int n; VL_int m]) -> Just (VL_bits (subrange_vec_dec bv n m) d)
  | ("vector_access", [VL_bits bv _; VL_int n]) -> Just (VL_bit (access_vec_dec bv n))
  | ("vector_update_subrange", [VL_bits bv1 d; VL_int n; VL_int m; VL_bits bv2 _]) -> Just (VL_bits (update_subrange_vec_dec bv1 n m bv2) d)
  | ("sail_truncate", [VL_bits bv d; VL_int n]) -> Just (VL_bits (vector_truncate bv n) d)
  | ("sail_truncateLSB", [VL_bits bv d; VL_int n]) -> Just (VL_bits (vector_truncateLSB bv n) d)

  (* lib/string.sail *)
  | ("eq_string", [VL_string s1; VL_string s2]) -> Just (VL_bool (s1 = s2))
  | ("concat_str", [VL_string s1; VL_string s2]) -> Just (VL_string (s1 ^ s2))
  | ("print_endline", [VL_string s]) -> Just VL_unit

  (* lib/mapping.sail *)
  | ("hex_parse", [VL_int n; VL_string hex]) -> mk_bits (hex_parse n hex)
  | ("hex_string", [VL_bits bv _]) -> Just (VL_string (show_bitlist bv))
  | ("decimal_parse", [VL_int n; VL_string dec]) -> mk_bits (decimal_parse n dec)

  (* option -undefined_gen *)
  | ("undefined_bit", [_]) -> Just (VL_bit B0)
  | ("undefined_vector", [VL_int n; VL_bit b]) -> Just (VL_bits (replicate_bits [b] n) true)

  | (_, _) -> Nothing
  end
