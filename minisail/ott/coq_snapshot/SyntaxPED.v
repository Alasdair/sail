(* generated by Ott 0.28 from: minisailplus_ast_vct.ott common.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Require Import SyntaxVCT.

Inductive loc : Set :=
  | Unknown.

Inductive xbc : Set :=
 | XBC_triple (xp5:xp) (bp5:bp) (cp5:cp).

(*Definition klist : Set := list_xp_bp_cp.*)

Definition klist : Set := list xbc.


Definition pos := nat. (*r Source file position *)
Lemma eq_pos: forall (x y : pos), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_pos : ott_coq_equality.
Definition up := nat. (*r Mutable Variables *)
Lemma eq_up: forall (x y : up), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_up : ott_coq_equality.

Inductive patp : Set :=  (*r Patterns *)
 | Pp_lit (lit5:lit)
 | Pp_wild : patp
 | Pp_as_var (patp5:patp) (xp5:xp) (*r pattern as an immutable variable *)
 | Pp_typ (tp5:tp) (patp5:patp) (*r pattern cast *)
 | Pp_id (id5:id)
 | Pp_as_typ (patp5:patp) (tp5:tp) (*r pattern as a type-variable *)
 | Pp_app (id5:id) (_:list patp)
 | Pp_vector (_:list patp) (*r vector pattern *)
 | Pp_vector_concat (_:list patp) (*r concatenated vector pattern *)
 | Pp_tup (_:list patp) (*r tuple pattern *)
 | Pp_list (_:list patp) (*r list pattern *)
 | Pp_cons (patp1:patp) (patp2:patp) (*r cons pattern *)
 | Pp_string_append (_:list patp) (*r string append pattern *).

Inductive lexpp : Set :=  (*r L-value expressions. Subset of Sail's but much of Sail's lexp is sugar *)
 | LEXPp_mvar (up5:up) (*r mutable variable *)
 | LEXPp_cast (tp5:tp) (up5:up) (*r cast *)
 | LEXPp_tup (_:list lexpp) (*r multiple (non-memory) assignment *)
 | LEXPp_field (lexpp5:lexpp) (id5:id) (*r struct field *).

Inductive pexpp : Set :=  (*r Pattern Expressions *)
 | PEXPp_exp (patp5:patp) (ep5:ep)
 | PEXPp_when (patp5:patp) (ep1:ep) (ep2:ep) (*r guarded pattern expression *)
with letbindp : Set := 
 | LBp_val (patp5:patp) (ep5:ep) (*r let, implicit type ($(patp5:patp)$ must be total) *)
with ep : Set :=  (*r Expressions *)
 | Ep_val (vp5:vp) (*r value *)
 | Ep_mvar (up5:up) (*r mutable variable *)
 | Ep_concat (_:list ep) (*r vector concatenation *)
 | Ep_tuple (_:list ep) (*r tuple *)
 | Ep_app (fp:xp) (ep5:ep) (*r function application *)
 | Ep_bop (bop5:bop) (ep1:ep) (ep2:ep) (*r binary operation *)
 | Ep_uop (uop5:uop) (ep5:ep) (*r unary operation *)
 | Ep_proj (p5:nat) (ep5:ep) (*r projection from a tuple *)
 | Ep_constr (ctor5:ctor) (ep5:ep) (*r constructor application *)
 | Ep_field_access (ep5:ep) (field5:field) (*r field access *)
 | Ep_sizeof (cep5:cep) (*r progmram level expression from t. Note this deliberately diverges from sail.ott AST *)
 | Ep_cast (tp5:tp) (ep5:ep) (*r type cast *)
 | Ep_record (_:list (field*ep)) (*r record *)
 | Ep_record_update (ep_5:ep) (_:list (field*ep)) (*r record update *)
 | Ep_let (letbindp5:letbindp) (ep2:ep) (*r let binding *)
 | Ep_let2 (xp5:xp) (tp5:tp) (ep1:ep) (ep2:ep) (*r let binding with type annotation *)
 | Ep_if (ep1:ep) (ep2:ep) (ep3:ep) (*r if statement *)
 | Ep_block (_:list ep) (*r sequential block *)
 | Ep_case (ep5:ep) (_:list pexpp) (*r case/match statement *)
 | Ep_assign (lexpp5:lexpp) (ep1:ep) (ep2:ep) (*r mutable variable assignment and scoping *)
 | Ep_exit (ep5:ep) (*r program exit *)
 | Ep_return (ep5:ep) (*r function return *)
 | Ep_throw (ep5:ep) (*r exception throw *)
 | Ep_try (ep5:ep) (_:list pexpp) (*r try block *)
 | Ep_constraint (cp5:cp) (*r constraint *)
 | Ep_loop (loop5:loop) (ep1:ep) (ep2:ep) (*r general loop *)
 | Ep_for (id5:id) (ep1:ep) (ep2:ep) (ep3:ep) (order5:order) (ep4:ep)
 | Ep_assert (ep1:ep) (ep2:ep) (*r assert *)
 | Ep_vec (_:list ep) (*r vector *)
 | Ep_list (_:list ep) (*r list *)
 | Ep_cons (ep1:ep) (ep2:ep) (*r list cons *).

Inductive tannot_opt_p : Set :=  (*r Function type annotation *)
 | Typ_annot_opt_pnone : tannot_opt_p
 | Typ_annot_opt_psome (klist5:klist) (tp5:tp)
 | Typ_annot_opt_psome_fn (ap5:ap).

Inductive funclp : Set :=  (*r Function clause *)
 | FCLp_funcl (id5:id) (pexpp5:pexpp).

Inductive scattered_defp : Set :=  (*r Scattered definition *)
 | SDp_function (tannot_opt_p5:tannot_opt_p) (id5:id)
 | SDp_variant (id5:id) (_:list (xp*bp*cp))
 | SDp_unioncl (id1:id) (id2:id) (tp5:tp)
 | SDp_funclp (funclp5:funclp)
 | SDp_end (id5:id).

Inductive defp : Set :=  (*r Definitions *)
 | DEFp_fundef (ap5:ap) (_:list funclp) (*r function *)
 | DEFp_typedef (id5:id) (_:list (xp*bp*cp)) (tp5:tp) (*r type *)
 | DEFp_spec (id5:id) (ap5:ap) (*r val type spec *)
 | DEFp_val (letbindp5:letbindp) (*r let binding *)
 | DEFp_reg (tp5:tp) (xp5:xp) (*r register *)
 | DEFp_overload (id_5:id) (_:list id) (*r operator overloading *)
 | DEFp_scattered (scattered_defp5:scattered_defp) (*r scattered definition *)
 | DEFp_default (order5:order) (*r default order spec *).

Inductive progp : Set :=  (*r program *)
 | Pp_prog (_:list defp) (*r program is just a list of definitions *).
(** induction principles *)
Section patp_rect.

Variables
  (P_patp : patp -> Prop)
  (P_list_patp : list patp -> Prop).

Hypothesis
  (H_Pp_lit : forall (lit5:lit), P_patp (Pp_lit lit5))
  (H_Pp_wild : P_patp Pp_wild)
  (H_Pp_as_var : forall (patp5:patp), P_patp patp5 -> forall (xp5:xp), P_patp (Pp_as_var patp5 xp5))
  (H_Pp_typ : forall (tp5:tp), forall (patp5:patp), P_patp patp5 -> P_patp (Pp_typ tp5 patp5))
  (H_Pp_id : forall (id5:id), P_patp (Pp_id id5))
  (H_Pp_as_typ : forall (patp5:patp), P_patp patp5 -> forall (tp5:tp), P_patp (Pp_as_typ patp5 tp5))
  (H_Pp_app : forall (patp_list:list patp), P_list_patp patp_list -> forall (id5:id), P_patp (Pp_app id5 patp_list))
  (H_Pp_vector : forall (patp_list:list patp), P_list_patp patp_list -> P_patp (Pp_vector patp_list))
  (H_Pp_vector_concat : forall (patp_list:list patp), P_list_patp patp_list -> P_patp (Pp_vector_concat patp_list))
  (H_Pp_tup : forall (patp_list:list patp), P_list_patp patp_list -> P_patp (Pp_tup patp_list))
  (H_Pp_list : forall (patp_list:list patp), P_list_patp patp_list -> P_patp (Pp_list patp_list))
  (H_Pp_cons : forall (patp1:patp), P_patp patp1 -> forall (patp2:patp), P_patp patp2 -> P_patp (Pp_cons patp1 patp2))
  (H_Pp_string_append : forall (patp_list:list patp), P_list_patp patp_list -> P_patp (Pp_string_append patp_list))
  (H_list_patp_nil : P_list_patp nil)
  (H_list_patp_cons : forall (patp0:patp), P_patp patp0 -> forall (patp_l:list patp), P_list_patp patp_l -> P_list_patp (cons patp0 patp_l)).

Fixpoint patp_ott_ind (n:patp) : P_patp n :=
  match n as x return P_patp x with
  | (Pp_lit lit5) => H_Pp_lit lit5
  | Pp_wild => H_Pp_wild 
  | (Pp_as_var patp5 xp5) => H_Pp_as_var patp5 (patp_ott_ind patp5) xp5
  | (Pp_typ tp5 patp5) => H_Pp_typ tp5 patp5 (patp_ott_ind patp5)
  | (Pp_id id5) => H_Pp_id id5
  | (Pp_as_typ patp5 tp5) => H_Pp_as_typ patp5 (patp_ott_ind patp5) tp5
  | (Pp_app id5 patp_list) => H_Pp_app patp_list (((fix patp_list_ott_ind (patp_l:list patp) : P_list_patp patp_l := match patp_l as x return P_list_patp x with nil => H_list_patp_nil | cons patp1 xl => H_list_patp_cons patp1(patp_ott_ind patp1)xl (patp_list_ott_ind xl) end)) patp_list) id5
  | (Pp_vector patp_list) => H_Pp_vector patp_list (((fix patp_list_ott_ind (patp_l:list patp) : P_list_patp patp_l := match patp_l as x return P_list_patp x with nil => H_list_patp_nil | cons patp2 xl => H_list_patp_cons patp2(patp_ott_ind patp2)xl (patp_list_ott_ind xl) end)) patp_list)
  | (Pp_vector_concat patp_list) => H_Pp_vector_concat patp_list (((fix patp_list_ott_ind (patp_l:list patp) : P_list_patp patp_l := match patp_l as x return P_list_patp x with nil => H_list_patp_nil | cons patp3 xl => H_list_patp_cons patp3(patp_ott_ind patp3)xl (patp_list_ott_ind xl) end)) patp_list)
  | (Pp_tup patp_list) => H_Pp_tup patp_list (((fix patp_list_ott_ind (patp_l:list patp) : P_list_patp patp_l := match patp_l as x return P_list_patp x with nil => H_list_patp_nil | cons patp4 xl => H_list_patp_cons patp4(patp_ott_ind patp4)xl (patp_list_ott_ind xl) end)) patp_list)
  | (Pp_list patp_list) => H_Pp_list patp_list (((fix patp_list_ott_ind (patp_l:list patp) : P_list_patp patp_l := match patp_l as x return P_list_patp x with nil => H_list_patp_nil | cons patp5 xl => H_list_patp_cons patp5(patp_ott_ind patp5)xl (patp_list_ott_ind xl) end)) patp_list)
  | (Pp_cons patp1 patp2) => H_Pp_cons patp1 (patp_ott_ind patp1) patp2 (patp_ott_ind patp2)
  | (Pp_string_append patp_list) => H_Pp_string_append patp_list (((fix patp_list_ott_ind (patp_l:list patp) : P_list_patp patp_l := match patp_l as x return P_list_patp x with nil => H_list_patp_nil | cons patp6 xl => H_list_patp_cons patp6(patp_ott_ind patp6)xl (patp_list_ott_ind xl) end)) patp_list)
end.

End patp_rect.


Section lexpp_rect.

Variables
  (P_list_lexpp : list lexpp -> Prop)
  (P_lexpp : lexpp -> Prop).

Hypothesis
  (H_LEXPp_mvar : forall (up5:up), P_lexpp (LEXPp_mvar up5))
  (H_LEXPp_cast : forall (tp5:tp), forall (up5:up), P_lexpp (LEXPp_cast tp5 up5))
  (H_LEXPp_tup : forall (lexpp_list:list lexpp), P_list_lexpp lexpp_list -> P_lexpp (LEXPp_tup lexpp_list))
  (H_LEXPp_field : forall (lexpp5:lexpp), P_lexpp lexpp5 -> forall (id5:id), P_lexpp (LEXPp_field lexpp5 id5))
  (H_list_lexpp_nil : P_list_lexpp nil)
  (H_list_lexpp_cons : forall (lexpp0:lexpp), P_lexpp lexpp0 -> forall (lexpp_l:list lexpp), P_list_lexpp lexpp_l -> P_list_lexpp (cons lexpp0 lexpp_l)).

Fixpoint lexpp_ott_ind (n:lexpp) : P_lexpp n :=
  match n as x return P_lexpp x with
  | (LEXPp_mvar up5) => H_LEXPp_mvar up5
  | (LEXPp_cast tp5 up5) => H_LEXPp_cast tp5 up5
  | (LEXPp_tup lexpp_list) => H_LEXPp_tup lexpp_list (((fix lexpp_list_ott_ind (lexpp_l:list lexpp) : P_list_lexpp lexpp_l := match lexpp_l as x return P_list_lexpp x with nil => H_list_lexpp_nil | cons lexpp1 xl => H_list_lexpp_cons lexpp1(lexpp_ott_ind lexpp1)xl (lexpp_list_ott_ind xl) end)) lexpp_list)
  | (LEXPp_field lexpp5 id5) => H_LEXPp_field lexpp5 (lexpp_ott_ind lexpp5) id5
end.

End lexpp_rect.


Section ep_letbindp_pexpp_rect.

Variables
  (P_pexpp : pexpp -> Prop)
  (P_list_field_ep : list (field*ep) -> Prop)
  (P_letbindp : letbindp -> Prop)
  (P_list_pexpp : list pexpp -> Prop)
  (P_list_ep : list ep -> Prop)
  (P_ep : ep -> Prop).

Hypothesis
  (H_Ep_val : forall (vp5:vp), P_ep (Ep_val vp5))
  (H_Ep_mvar : forall (up5:up), P_ep (Ep_mvar up5))
  (H_Ep_concat : forall (ep_list:list ep), P_list_ep ep_list -> P_ep (Ep_concat ep_list))
  (H_Ep_tuple : forall (ep_list:list ep), P_list_ep ep_list -> P_ep (Ep_tuple ep_list))
  (H_Ep_app : forall (fp:xp), forall (ep5:ep), P_ep ep5 -> P_ep (Ep_app fp ep5))
  (H_Ep_bop : forall (bop5:bop), forall (ep1:ep), P_ep ep1 -> forall (ep2:ep), P_ep ep2 -> P_ep (Ep_bop bop5 ep1 ep2))
  (H_Ep_uop : forall (uop5:uop), forall (ep5:ep), P_ep ep5 -> P_ep (Ep_uop uop5 ep5))
  (H_Ep_proj : forall (p5:nat), forall (ep5:ep), P_ep ep5 -> P_ep (Ep_proj p5 ep5))
  (H_Ep_constr : forall (ctor5:ctor), forall (ep5:ep), P_ep ep5 -> P_ep (Ep_constr ctor5 ep5))
  (H_Ep_field_access : forall (ep5:ep), P_ep ep5 -> forall (field5:field), P_ep (Ep_field_access ep5 field5))
  (H_Ep_sizeof : forall (cep5:cep), P_ep (Ep_sizeof cep5))
  (H_Ep_cast : forall (tp5:tp), forall (ep5:ep), P_ep ep5 -> P_ep (Ep_cast tp5 ep5))
  (H_Ep_record : forall (field_ep_list:list (field*ep)), P_list_field_ep field_ep_list -> P_ep (Ep_record field_ep_list))
  (H_Ep_record_update : forall (field_ep_list:list (field*ep)), P_list_field_ep field_ep_list -> forall (ep_5:ep), P_ep ep_5 -> P_ep (Ep_record_update ep_5 field_ep_list))
  (H_Ep_let : forall (letbindp5:letbindp), P_letbindp letbindp5 -> forall (ep2:ep), P_ep ep2 -> P_ep (Ep_let letbindp5 ep2))
  (H_Ep_let2 : forall (xp5:xp), forall (tp5:tp), forall (ep1:ep), P_ep ep1 -> forall (ep2:ep), P_ep ep2 -> P_ep (Ep_let2 xp5 tp5 ep1 ep2))
  (H_Ep_if : forall (ep1:ep), P_ep ep1 -> forall (ep2:ep), P_ep ep2 -> forall (ep3:ep), P_ep ep3 -> P_ep (Ep_if ep1 ep2 ep3))
  (H_Ep_block : forall (ep_list:list ep), P_list_ep ep_list -> P_ep (Ep_block ep_list))
  (H_Ep_case : forall (pexpp_list:list pexpp), P_list_pexpp pexpp_list -> forall (ep5:ep), P_ep ep5 -> P_ep (Ep_case ep5 pexpp_list))
  (H_Ep_assign : forall (lexpp5:lexpp), forall (ep1:ep), P_ep ep1 -> forall (ep2:ep), P_ep ep2 -> P_ep (Ep_assign lexpp5 ep1 ep2))
  (H_Ep_exit : forall (ep5:ep), P_ep ep5 -> P_ep (Ep_exit ep5))
  (H_Ep_return : forall (ep5:ep), P_ep ep5 -> P_ep (Ep_return ep5))
  (H_Ep_throw : forall (ep5:ep), P_ep ep5 -> P_ep (Ep_throw ep5))
  (H_Ep_try : forall (pexpp_list:list pexpp), P_list_pexpp pexpp_list -> forall (ep5:ep), P_ep ep5 -> P_ep (Ep_try ep5 pexpp_list))
  (H_Ep_constraint : forall (cp5:cp), P_ep (Ep_constraint cp5))
  (H_Ep_loop : forall (loop5:loop), forall (ep1:ep), P_ep ep1 -> forall (ep2:ep), P_ep ep2 -> P_ep (Ep_loop loop5 ep1 ep2))
  (H_Ep_for : forall (id5:id), forall (ep1:ep), P_ep ep1 -> forall (ep2:ep), P_ep ep2 -> forall (ep3:ep), P_ep ep3 -> forall (order5:order), forall (ep4:ep), P_ep ep4 -> P_ep (Ep_for id5 ep1 ep2 ep3 order5 ep4))
  (H_Ep_assert : forall (ep1:ep), P_ep ep1 -> forall (ep2:ep), P_ep ep2 -> P_ep (Ep_assert ep1 ep2))
  (H_Ep_vec : forall (ep_list:list ep), P_list_ep ep_list -> P_ep (Ep_vec ep_list))
  (H_Ep_list : forall (ep_list:list ep), P_list_ep ep_list -> P_ep (Ep_list ep_list))
  (H_Ep_cons : forall (ep1:ep), P_ep ep1 -> forall (ep2:ep), P_ep ep2 -> P_ep (Ep_cons ep1 ep2))
  (H_LBp_val : forall (patp5:patp), forall (ep5:ep), P_ep ep5 -> P_letbindp (LBp_val patp5 ep5))
  (H_PEXPp_exp : forall (patp5:patp), forall (ep5:ep), P_ep ep5 -> P_pexpp (PEXPp_exp patp5 ep5))
  (H_PEXPp_when : forall (patp5:patp), forall (ep1:ep), P_ep ep1 -> forall (ep2:ep), P_ep ep2 -> P_pexpp (PEXPp_when patp5 ep1 ep2))
  (H_list_field_ep_nil : P_list_field_ep nil)
  (H_list_field_ep_cons : forall (field0:field), forall (ep0:ep), P_ep ep0 -> forall (field_ep_l:list (field*ep)), P_list_field_ep field_ep_l -> P_list_field_ep (cons (field0,ep0) field_ep_l))
  (H_list_pexpp_nil : P_list_pexpp nil)
  (H_list_pexpp_cons : forall (pexpp0:pexpp), P_pexpp pexpp0 -> forall (pexpp_l:list pexpp), P_list_pexpp pexpp_l -> P_list_pexpp (cons pexpp0 pexpp_l))
  (H_list_ep_nil : P_list_ep nil)
  (H_list_ep_cons : forall (ep1:ep), P_ep ep1 -> forall (ep_l:list ep), P_list_ep ep_l -> P_list_ep (cons ep1 ep_l)).

Fixpoint pexpp_ott_ind (n:pexpp) : P_pexpp n :=
  match n as x return P_pexpp x with
  | (PEXPp_exp patp5 ep5) => H_PEXPp_exp patp5 ep5 (ep_ott_ind ep5)
  | (PEXPp_when patp5 ep1 ep2) => H_PEXPp_when patp5 ep1 (ep_ott_ind ep1) ep2 (ep_ott_ind ep2)
end
with letbindp_ott_ind (n:letbindp) : P_letbindp n :=
  match n as x return P_letbindp x with
  | (LBp_val patp5 ep5) => H_LBp_val patp5 ep5 (ep_ott_ind ep5)
end
with ep_ott_ind (n:ep) : P_ep n :=
  match n as x return P_ep x with
  | (Ep_val vp5) => H_Ep_val vp5
  | (Ep_mvar up5) => H_Ep_mvar up5
  | (Ep_concat ep_list) => H_Ep_concat ep_list (((fix ep_list_ott_ind (ep_l:list ep) : P_list_ep ep_l := match ep_l as x return P_list_ep x with nil => H_list_ep_nil | cons ep2 xl => H_list_ep_cons ep2(ep_ott_ind ep2)xl (ep_list_ott_ind xl) end)) ep_list)
  | (Ep_tuple ep_list) => H_Ep_tuple ep_list (((fix ep_list_ott_ind (ep_l:list ep) : P_list_ep ep_l := match ep_l as x return P_list_ep x with nil => H_list_ep_nil | cons ep3 xl => H_list_ep_cons ep3(ep_ott_ind ep3)xl (ep_list_ott_ind xl) end)) ep_list)
  | (Ep_app fp ep5) => H_Ep_app fp ep5 (ep_ott_ind ep5)
  | (Ep_bop bop5 ep1 ep2) => H_Ep_bop bop5 ep1 (ep_ott_ind ep1) ep2 (ep_ott_ind ep2)
  | (Ep_uop uop5 ep5) => H_Ep_uop uop5 ep5 (ep_ott_ind ep5)
  | (Ep_proj p5 ep5) => H_Ep_proj p5 ep5 (ep_ott_ind ep5)
  | (Ep_constr ctor5 ep5) => H_Ep_constr ctor5 ep5 (ep_ott_ind ep5)
  | (Ep_field_access ep5 field5) => H_Ep_field_access ep5 (ep_ott_ind ep5) field5
  | (Ep_sizeof cep5) => H_Ep_sizeof cep5
  | (Ep_cast tp5 ep5) => H_Ep_cast tp5 ep5 (ep_ott_ind ep5)
  | (Ep_record field_ep_list) => H_Ep_record field_ep_list (((fix field_ep_list_ott_ind (field_ep_l:list (field*ep)) : P_list_field_ep field_ep_l := match field_ep_l as x return P_list_field_ep x with nil => H_list_field_ep_nil | cons (field1,ep4) xl => H_list_field_ep_cons field1  ep4(ep_ott_ind ep4)xl (field_ep_list_ott_ind xl) end)) field_ep_list)
  | (Ep_record_update ep_5 field_ep_list) => H_Ep_record_update field_ep_list (((fix field_ep_list_ott_ind (field_ep_l:list (field*ep)) : P_list_field_ep field_ep_l := match field_ep_l as x return P_list_field_ep x with nil => H_list_field_ep_nil | cons (field2,ep5) xl => H_list_field_ep_cons field2  ep5(ep_ott_ind ep5)xl (field_ep_list_ott_ind xl) end)) field_ep_list) ep_5 (ep_ott_ind ep_5)
  | (Ep_let letbindp5 ep2) => H_Ep_let letbindp5 (letbindp_ott_ind letbindp5) ep2 (ep_ott_ind ep2)
  | (Ep_let2 xp5 tp5 ep1 ep2) => H_Ep_let2 xp5 tp5 ep1 (ep_ott_ind ep1) ep2 (ep_ott_ind ep2)
  | (Ep_if ep1 ep2 ep3) => H_Ep_if ep1 (ep_ott_ind ep1) ep2 (ep_ott_ind ep2) ep3 (ep_ott_ind ep3)
  | (Ep_block ep_list) => H_Ep_block ep_list (((fix ep_list_ott_ind (ep_l:list ep) : P_list_ep ep_l := match ep_l as x return P_list_ep x with nil => H_list_ep_nil | cons ep6 xl => H_list_ep_cons ep6(ep_ott_ind ep6)xl (ep_list_ott_ind xl) end)) ep_list)
  | (Ep_case ep5 pexpp_list) => H_Ep_case pexpp_list (((fix pexpp_list_ott_ind (pexpp_l:list pexpp) : P_list_pexpp pexpp_l := match pexpp_l as x return P_list_pexpp x with nil => H_list_pexpp_nil | cons pexpp1 xl => H_list_pexpp_cons pexpp1(pexpp_ott_ind pexpp1)xl (pexpp_list_ott_ind xl) end)) pexpp_list) ep5 (ep_ott_ind ep5)
  | (Ep_assign lexpp5 ep1 ep2) => H_Ep_assign lexpp5 ep1 (ep_ott_ind ep1) ep2 (ep_ott_ind ep2)
  | (Ep_exit ep5) => H_Ep_exit ep5 (ep_ott_ind ep5)
  | (Ep_return ep5) => H_Ep_return ep5 (ep_ott_ind ep5)
  | (Ep_throw ep5) => H_Ep_throw ep5 (ep_ott_ind ep5)
  | (Ep_try ep5 pexpp_list) => H_Ep_try pexpp_list (((fix pexpp_list_ott_ind (pexpp_l:list pexpp) : P_list_pexpp pexpp_l := match pexpp_l as x return P_list_pexpp x with nil => H_list_pexpp_nil | cons pexpp2 xl => H_list_pexpp_cons pexpp2(pexpp_ott_ind pexpp2)xl (pexpp_list_ott_ind xl) end)) pexpp_list) ep5 (ep_ott_ind ep5)
  | (Ep_constraint cp5) => H_Ep_constraint cp5
  | (Ep_loop loop5 ep1 ep2) => H_Ep_loop loop5 ep1 (ep_ott_ind ep1) ep2 (ep_ott_ind ep2)
  | (Ep_for id5 ep1 ep2 ep3 order5 ep4) => H_Ep_for id5 ep1 (ep_ott_ind ep1) ep2 (ep_ott_ind ep2) ep3 (ep_ott_ind ep3) order5 ep4 (ep_ott_ind ep4)
  | (Ep_assert ep1 ep2) => H_Ep_assert ep1 (ep_ott_ind ep1) ep2 (ep_ott_ind ep2)
  | (Ep_vec ep_list) => H_Ep_vec ep_list (((fix ep_list_ott_ind (ep_l:list ep) : P_list_ep ep_l := match ep_l as x return P_list_ep x with nil => H_list_ep_nil | cons ep7 xl => H_list_ep_cons ep7(ep_ott_ind ep7)xl (ep_list_ott_ind xl) end)) ep_list)
  | (Ep_list ep_list) => H_Ep_list ep_list (((fix ep_list_ott_ind (ep_l:list ep) : P_list_ep ep_l := match ep_l as x return P_list_ep x with nil => H_list_ep_nil | cons ep8 xl => H_list_ep_cons ep8(ep_ott_ind ep8)xl (ep_list_ott_ind xl) end)) ep_list)
  | (Ep_cons ep1 ep2) => H_Ep_cons ep1 (ep_ott_ind ep1) ep2 (ep_ott_ind ep2)
end.

End ep_letbindp_pexpp_rect.
(** library functions *)
Fixpoint list_mem A (eq:forall a b:A,{a=b}+{a<>b}) (x:A) (l:list A) {struct l} : bool :=
  match l with
  | nil => false
  | cons h t => if eq h x then true else list_mem A eq x t
end.
Implicit Arguments list_mem.


(** substitutions *)
Fixpoint subst_vp (vp_6:vp) (zp5:xp) (vp__7:vp) {struct vp__7} : vp :=
  match vp__7 with
  | (V_lit lit5) => V_lit lit5
  | (V_var xp5) => (if eq_xp xp5 zp5 then vp_6 else (V_var xp5))
  | (V_vec vp_list) => V_vec (map (fun (vp_:vp) => (subst_vp vp_6 zp5 vp_)) vp_list)
  | (V_list vp_list) => V_list (map (fun (vp_:vp) => (subst_vp vp_6 zp5 vp_)) vp_list)
  | (V_cons vp1 vp2) => V_cons (subst_vp vp_6 zp5 vp1) (subst_vp vp_6 zp5 vp2)
  | (V_constr ctor5 vp5) => V_constr ctor5 (subst_vp vp_6 zp5 vp5)
  | (V_record field_vp_list) => V_record (map (fun (pat_:(field*vp)) => match pat_ with (field_,vp_) => (field_,(subst_vp vp_6 zp5 vp_)) end) field_vp_list)
  | (V_tuple vp_list) => V_tuple (map (fun (vp_:vp) => (subst_vp vp_6 zp5 vp_)) vp_list)
  | (V_proj p5 vp5) => V_proj p5 (subst_vp vp_6 zp5 vp5)
end.

Fixpoint subst_cep (vp_6:vp) (zp5:xp) (cep_6:cep) {struct cep_6} : cep :=
  match cep_6 with
  | (CE_val vp5) => CE_val (subst_vp vp_6 zp5 vp5)
  | (CE_bop cep1 bop5 cep2) => CE_bop (subst_cep vp_6 zp5 cep1) bop5 (subst_cep vp_6 zp5 cep2)
  | (CE_many_plus cep_list) => CE_many_plus (map (fun (cep_:cep) => (subst_cep vp_6 zp5 cep_)) cep_list)
  | (CE_uop uop5 cep5) => CE_uop uop5 (subst_cep vp_6 zp5 cep5)
  | (CE_proj p5 cep5) => CE_proj p5 (subst_cep vp_6 zp5 cep5)
  | (CE_field_access xp5 field5) => CE_field_access xp5 field5
end.

Fixpoint subst_cp (vp_6:vp) (zp5:xp) (cp_6:cp) {struct cp_6} : cp :=
  match cp_6 with
  | C_true => C_true 
  | C_false => C_false 
  | (C_conj cp1 cp2) => C_conj (subst_cp vp_6 zp5 cp1) (subst_cp vp_6 zp5 cp2)
  | (C_conj_many cp_list) => C_conj_many (map (fun (cp_:cp) => (subst_cp vp_6 zp5 cp_)) cp_list)
  | (C_disj cp1 cp2) => C_disj (subst_cp vp_6 zp5 cp1) (subst_cp vp_6 zp5 cp2)
  | (C_not cp5) => C_not (subst_cp vp_6 zp5 cp5)
  | (C_eq cep1 cep2) => C_eq (subst_cep vp_6 zp5 cep1) (subst_cep vp_6 zp5 cep2)
  | (C_leq cep1 cep2) => C_leq (subst_cep vp_6 zp5 cep1) (subst_cep vp_6 zp5 cep2)
  | (C_imp cp1 cp2) => C_imp (subst_cp vp_6 zp5 cp1) (subst_cp vp_6 zp5 cp2)
end.

Fixpoint subst_tp (vp_6:vp) (zp5:xp) (tp_6:tp) {struct tp_6} : tp :=
  match tp_6 with
  | (T_refined_type zp bp5 cp5) => T_refined_type zp (subst_bp vp_6 zp5 bp5) (subst_cp vp_6 zp5 cp5)
end
with subst_bp (vp5:vp) (zp5:xp) (bp_6:bp) {struct bp_6} : bp :=
  match bp_6 with
  | (B_var tvar5) => B_var tvar5
  | (B_tid id5) => B_tid id5
  | B_int => B_int 
  | B_bool => B_bool 
  | B_bit => B_bit 
  | B_unit => B_unit 
  | B_real => B_real 
  | (B_vec order5 bp5) => B_vec order5 (subst_bp vp5 zp5 bp5)
  | (B_list bp5) => B_list (subst_bp vp5 zp5 bp5)
  | (B_tuple bp_list) => B_tuple (map (fun (bp_:bp) => (subst_bp vp5 zp5 bp_)) bp_list)
  | (B_union id5 ctor_tp_list) => B_union id5 (map (fun (pat_:(ctor*tp)) => match pat_ with (ctor_,tp_) => (ctor_,(subst_tp vp5 zp5 tp_)) end) ctor_tp_list)
  | (B_record field_bp_list) => B_record (map (fun (pat_:(field*bp)) => match pat_ with (field_,bp_) => (field_,(subst_bp vp5 zp5 bp_)) end) field_bp_list)
  | B_undef => B_undef 
  | B_reg => B_reg 
  | B_string => B_string 
  | B_exception => B_exception 
  | (B_finite_set num_list) => B_finite_set num_list
end.

Fixpoint tsubst_tp (bp_6:bp) (tvar5:tvar) (tp_6:tp) {struct tp_6} : tp :=
  match tp_6 with
  | (T_refined_type zp bp5 cp5) => T_refined_type zp (tsubst_bp bp_6 tvar5 bp5) cp5
end
with tsubst_bp (bp_6:bp) (tvar_6:tvar) (bp__7:bp) {struct bp__7} : bp :=
  match bp__7 with
  | (B_var tvar5) => (if eq_tvar tvar5 tvar_6 then bp_6 else (B_var tvar5))
  | (B_tid id5) => B_tid id5
  | B_int => B_int 
  | B_bool => B_bool 
  | B_bit => B_bit 
  | B_unit => B_unit 
  | B_real => B_real 
  | (B_vec order5 bp5) => B_vec order5 (tsubst_bp bp_6 tvar_6 bp5)
  | (B_list bp5) => B_list (tsubst_bp bp_6 tvar_6 bp5)
  | (B_tuple bp_list) => B_tuple (map (fun (bp_:bp) => (tsubst_bp bp_6 tvar_6 bp_)) bp_list)
  | (B_union id5 ctor_tp_list) => B_union id5 (map (fun (pat_:(ctor*tp)) => match pat_ with (ctor_,tp_) => (ctor_,(tsubst_tp bp_6 tvar_6 tp_)) end) ctor_tp_list)
  | (B_record field_bp_list) => B_record (map (fun (pat_:(field*bp)) => match pat_ with (field_,bp_) => (field_,(tsubst_bp bp_6 tvar_6 bp_)) end) field_bp_list)
  | B_undef => B_undef 
  | B_reg => B_reg 
  | B_string => B_string 
  | B_exception => B_exception 
  | (B_finite_set num_list) => B_finite_set num_list
end.

Fixpoint subst_lexpp (vp5:vp) (zp5:xp) (lexpp_6:lexpp) {struct lexpp_6} : lexpp :=
  match lexpp_6 with
  | (LEXPp_mvar up5) => LEXPp_mvar up5
  | (LEXPp_cast tp5 up5) => LEXPp_cast (subst_tp vp5 zp5 tp5) up5
  | (LEXPp_tup lexpp_list) => LEXPp_tup (map (fun (lexpp_:lexpp) => (subst_lexpp vp5 zp5 lexpp_)) lexpp_list)
  | (LEXPp_field lexpp5 id5) => LEXPp_field (subst_lexpp vp5 zp5 lexpp5) id5
end.

Fixpoint subst_patp (vp_6:vp) (zp5:xp) (patp_6:patp) {struct patp_6} : patp :=
  match patp_6 with
  | (Pp_lit lit5) => Pp_lit lit5
  | Pp_wild => Pp_wild 
  | (Pp_as_var patp5 xp5) => Pp_as_var (subst_patp vp_6 zp5 patp5) xp5
  | (Pp_typ tp5 patp5) => Pp_typ (subst_tp vp_6 zp5 tp5) (subst_patp vp_6 zp5 patp5)
  | (Pp_id id5) => Pp_id id5
  | (Pp_as_typ patp5 tp5) => Pp_as_typ (subst_patp vp_6 zp5 patp5) (subst_tp vp_6 zp5 tp5)
  | (Pp_app id5 patp_list) => Pp_app id5 (map (fun (patp_:patp) => (subst_patp vp_6 zp5 patp_)) patp_list)
  | (Pp_vector patp_list) => Pp_vector (map (fun (patp_:patp) => (subst_patp vp_6 zp5 patp_)) patp_list)
  | (Pp_vector_concat patp_list) => Pp_vector_concat (map (fun (patp_:patp) => (subst_patp vp_6 zp5 patp_)) patp_list)
  | (Pp_tup patp_list) => Pp_tup (map (fun (patp_:patp) => (subst_patp vp_6 zp5 patp_)) patp_list)
  | (Pp_list patp_list) => Pp_list (map (fun (patp_:patp) => (subst_patp vp_6 zp5 patp_)) patp_list)
  | (Pp_cons patp1 patp2) => Pp_cons (subst_patp vp_6 zp5 patp1) (subst_patp vp_6 zp5 patp2)
  | (Pp_string_append patp_list) => Pp_string_append (map (fun (patp_:patp) => (subst_patp vp_6 zp5 patp_)) patp_list)
end.

Fixpoint tsubst_patp (bp5:bp) (tvar5:tvar) (patp_6:patp) {struct patp_6} : patp :=
  match patp_6 with
  | (Pp_lit lit5) => Pp_lit lit5
  | Pp_wild => Pp_wild 
  | (Pp_as_var patp5 xp5) => Pp_as_var (tsubst_patp bp5 tvar5 patp5) xp5
  | (Pp_typ tp5 patp5) => Pp_typ (tsubst_tp bp5 tvar5 tp5) (tsubst_patp bp5 tvar5 patp5)
  | (Pp_id id5) => Pp_id id5
  | (Pp_as_typ patp5 tp5) => Pp_as_typ (tsubst_patp bp5 tvar5 patp5) (tsubst_tp bp5 tvar5 tp5)
  | (Pp_app id5 patp_list) => Pp_app id5 (map (fun (patp_:patp) => (tsubst_patp bp5 tvar5 patp_)) patp_list)
  | (Pp_vector patp_list) => Pp_vector (map (fun (patp_:patp) => (tsubst_patp bp5 tvar5 patp_)) patp_list)
  | (Pp_vector_concat patp_list) => Pp_vector_concat (map (fun (patp_:patp) => (tsubst_patp bp5 tvar5 patp_)) patp_list)
  | (Pp_tup patp_list) => Pp_tup (map (fun (patp_:patp) => (tsubst_patp bp5 tvar5 patp_)) patp_list)
  | (Pp_list patp_list) => Pp_list (map (fun (patp_:patp) => (tsubst_patp bp5 tvar5 patp_)) patp_list)
  | (Pp_cons patp1 patp2) => Pp_cons (tsubst_patp bp5 tvar5 patp1) (tsubst_patp bp5 tvar5 patp2)
  | (Pp_string_append patp_list) => Pp_string_append (map (fun (patp_:patp) => (tsubst_patp bp5 tvar5 patp_)) patp_list)
end.

Fixpoint tsubst_lexpp (bp5:bp) (tvar5:tvar) (lexpp_6:lexpp) {struct lexpp_6} : lexpp :=
  match lexpp_6 with
  | (LEXPp_mvar up5) => LEXPp_mvar up5
  | (LEXPp_cast tp5 up5) => LEXPp_cast (tsubst_tp bp5 tvar5 tp5) up5
  | (LEXPp_tup lexpp_list) => LEXPp_tup (map (fun (lexpp_:lexpp) => (tsubst_lexpp bp5 tvar5 lexpp_)) lexpp_list)
  | (LEXPp_field lexpp5 id5) => LEXPp_field (tsubst_lexpp bp5 tvar5 lexpp5) id5
end.

Definition subst_ap (vp5:vp) (zp5:xp) (ap5:ap) : ap :=
  match ap5 with
  | (A_monotype tp5) => A_monotype (subst_tp vp5 zp5 tp5)
  | (A_function xp5 bp5 cp5 tp5) => A_function xp5 (subst_bp vp5 zp5 bp5) (subst_cp vp5 zp5 cp5) (subst_tp vp5 zp5 tp5)
end.

Fixpoint subst_ep (vp_6:vp) (zp5:xp) (ep__6:ep) {struct ep__6} : ep :=
  match ep__6 with
  | (Ep_val vp5) => Ep_val (subst_vp vp_6 zp5 vp5)
  | (Ep_mvar up5) => Ep_mvar up5
  | (Ep_concat ep_list) => Ep_concat (map (fun (ep_:ep) => (subst_ep vp_6 zp5 ep_)) ep_list)
  | (Ep_tuple ep_list) => Ep_tuple (map (fun (ep_:ep) => (subst_ep vp_6 zp5 ep_)) ep_list)
  | (Ep_app fp ep5) => Ep_app fp (subst_ep vp_6 zp5 ep5)
  | (Ep_bop bop5 ep1 ep2) => Ep_bop bop5 (subst_ep vp_6 zp5 ep1) (subst_ep vp_6 zp5 ep2)
  | (Ep_uop uop5 ep5) => Ep_uop uop5 (subst_ep vp_6 zp5 ep5)
  | (Ep_proj p5 ep5) => Ep_proj p5 (subst_ep vp_6 zp5 ep5)
  | (Ep_constr ctor5 ep5) => Ep_constr ctor5 (subst_ep vp_6 zp5 ep5)
  | (Ep_field_access ep5 field5) => Ep_field_access (subst_ep vp_6 zp5 ep5) field5
  | (Ep_sizeof cep5) => Ep_sizeof (subst_cep vp_6 zp5 cep5)
  | (Ep_cast tp5 ep5) => Ep_cast (subst_tp vp_6 zp5 tp5) (subst_ep vp_6 zp5 ep5)
  | (Ep_record field_ep_list) => Ep_record (map (fun (pat_:(field*ep)) => match pat_ with (field_,ep_) => (field_,(subst_ep vp_6 zp5 ep_)) end) field_ep_list)
  | (Ep_record_update ep_5 field_ep_list) => Ep_record_update (subst_ep vp_6 zp5 ep_5) (map (fun (pat_:(field*ep)) => match pat_ with (field_,ep_) => (field_,(subst_ep vp_6 zp5 ep_)) end) field_ep_list)
  | (Ep_let letbindp5 ep2) => Ep_let (subst_letbindp vp_6 zp5 letbindp5) (subst_ep vp_6 zp5 ep2)
  | (Ep_let2 xp5 tp5 ep1 ep2) => Ep_let2 xp5 (subst_tp vp_6 zp5 tp5) (subst_ep vp_6 zp5 ep1) (if list_mem eq_xp zp5 (cons xp5 nil) then ep2 else (subst_ep vp_6 zp5 ep2))
  | (Ep_if ep1 ep2 ep3) => Ep_if (subst_ep vp_6 zp5 ep1) (subst_ep vp_6 zp5 ep2) (subst_ep vp_6 zp5 ep3)
  | (Ep_block ep_list) => Ep_block (map (fun (ep_:ep) => (subst_ep vp_6 zp5 ep_)) ep_list)
  | (Ep_case ep5 pexpp_list) => Ep_case (subst_ep vp_6 zp5 ep5) (map (fun (pexpp_:pexpp) => (subst_pexpp vp_6 zp5 pexpp_)) pexpp_list)
  | (Ep_assign lexpp5 ep1 ep2) => Ep_assign (subst_lexpp vp_6 zp5 lexpp5) (subst_ep vp_6 zp5 ep1) (subst_ep vp_6 zp5 ep2)
  | (Ep_exit ep5) => Ep_exit (subst_ep vp_6 zp5 ep5)
  | (Ep_return ep5) => Ep_return (subst_ep vp_6 zp5 ep5)
  | (Ep_throw ep5) => Ep_throw (subst_ep vp_6 zp5 ep5)
  | (Ep_try ep5 pexpp_list) => Ep_try (subst_ep vp_6 zp5 ep5) (map (fun (pexpp_:pexpp) => (subst_pexpp vp_6 zp5 pexpp_)) pexpp_list)
  | (Ep_constraint cp5) => Ep_constraint (subst_cp vp_6 zp5 cp5)
  | (Ep_loop loop5 ep1 ep2) => Ep_loop loop5 (subst_ep vp_6 zp5 ep1) (subst_ep vp_6 zp5 ep2)
  | (Ep_for id5 ep1 ep2 ep3 order5 ep4) => Ep_for id5 (subst_ep vp_6 zp5 ep1) (subst_ep vp_6 zp5 ep2) (subst_ep vp_6 zp5 ep3) order5 (subst_ep vp_6 zp5 ep4)
  | (Ep_assert ep1 ep2) => Ep_assert (subst_ep vp_6 zp5 ep1) (subst_ep vp_6 zp5 ep2)
  | (Ep_vec ep_list) => Ep_vec (map (fun (ep_:ep) => (subst_ep vp_6 zp5 ep_)) ep_list)
  | (Ep_list ep_list) => Ep_list (map (fun (ep_:ep) => (subst_ep vp_6 zp5 ep_)) ep_list)
  | (Ep_cons ep1 ep2) => Ep_cons (subst_ep vp_6 zp5 ep1) (subst_ep vp_6 zp5 ep2)
end
with subst_letbindp (vp5:vp) (zp5:xp) (letbindp5:letbindp) {struct letbindp5} : letbindp :=
  match letbindp5 with
  | (LBp_val patp5 ep5) => LBp_val (subst_patp vp5 zp5 patp5) (subst_ep vp5 zp5 ep5)
end
with subst_pexpp (vp_6:vp) (zp5:xp) (pexpp_6:pexpp) {struct pexpp_6} : pexpp :=
  match pexpp_6 with
  | (PEXPp_exp patp5 ep5) => PEXPp_exp (subst_patp vp_6 zp5 patp5) (subst_ep vp_6 zp5 ep5)
  | (PEXPp_when patp5 ep1 ep2) => PEXPp_when (subst_patp vp_6 zp5 patp5) (subst_ep vp_6 zp5 ep1) (subst_ep vp_6 zp5 ep2)
end.

Fixpoint tsubst_ep (bp5:bp) (tvar5:tvar) (ep__6:ep) {struct ep__6} : ep :=
  match ep__6 with
  | (Ep_val vp5) => Ep_val vp5
  | (Ep_mvar up5) => Ep_mvar up5
  | (Ep_concat ep_list) => Ep_concat (map (fun (ep_:ep) => (tsubst_ep bp5 tvar5 ep_)) ep_list)
  | (Ep_tuple ep_list) => Ep_tuple (map (fun (ep_:ep) => (tsubst_ep bp5 tvar5 ep_)) ep_list)
  | (Ep_app fp ep5) => Ep_app fp (tsubst_ep bp5 tvar5 ep5)
  | (Ep_bop bop5 ep1 ep2) => Ep_bop bop5 (tsubst_ep bp5 tvar5 ep1) (tsubst_ep bp5 tvar5 ep2)
  | (Ep_uop uop5 ep5) => Ep_uop uop5 (tsubst_ep bp5 tvar5 ep5)
  | (Ep_proj p5 ep5) => Ep_proj p5 (tsubst_ep bp5 tvar5 ep5)
  | (Ep_constr ctor5 ep5) => Ep_constr ctor5 (tsubst_ep bp5 tvar5 ep5)
  | (Ep_field_access ep5 field5) => Ep_field_access (tsubst_ep bp5 tvar5 ep5) field5
  | (Ep_sizeof cep5) => Ep_sizeof cep5
  | (Ep_cast tp5 ep5) => Ep_cast (tsubst_tp bp5 tvar5 tp5) (tsubst_ep bp5 tvar5 ep5)
  | (Ep_record field_ep_list) => Ep_record (map (fun (pat_:(field*ep)) => match pat_ with (field_,ep_) => (field_,(tsubst_ep bp5 tvar5 ep_)) end) field_ep_list)
  | (Ep_record_update ep_5 field_ep_list) => Ep_record_update (tsubst_ep bp5 tvar5 ep_5) (map (fun (pat_:(field*ep)) => match pat_ with (field_,ep_) => (field_,(tsubst_ep bp5 tvar5 ep_)) end) field_ep_list)
  | (Ep_let letbindp5 ep2) => Ep_let (tsubst_letbindp bp5 tvar5 letbindp5) (tsubst_ep bp5 tvar5 ep2)
  | (Ep_let2 xp5 tp5 ep1 ep2) => Ep_let2 xp5 (tsubst_tp bp5 tvar5 tp5) (tsubst_ep bp5 tvar5 ep1) (tsubst_ep bp5 tvar5 ep2)
  | (Ep_if ep1 ep2 ep3) => Ep_if (tsubst_ep bp5 tvar5 ep1) (tsubst_ep bp5 tvar5 ep2) (tsubst_ep bp5 tvar5 ep3)
  | (Ep_block ep_list) => Ep_block (map (fun (ep_:ep) => (tsubst_ep bp5 tvar5 ep_)) ep_list)
  | (Ep_case ep5 pexpp_list) => Ep_case (tsubst_ep bp5 tvar5 ep5) (map (fun (pexpp_:pexpp) => (tsubst_pexpp bp5 tvar5 pexpp_)) pexpp_list)
  | (Ep_assign lexpp5 ep1 ep2) => Ep_assign (tsubst_lexpp bp5 tvar5 lexpp5) (tsubst_ep bp5 tvar5 ep1) (tsubst_ep bp5 tvar5 ep2)
  | (Ep_exit ep5) => Ep_exit (tsubst_ep bp5 tvar5 ep5)
  | (Ep_return ep5) => Ep_return (tsubst_ep bp5 tvar5 ep5)
  | (Ep_throw ep5) => Ep_throw (tsubst_ep bp5 tvar5 ep5)
  | (Ep_try ep5 pexpp_list) => Ep_try (tsubst_ep bp5 tvar5 ep5) (map (fun (pexpp_:pexpp) => (tsubst_pexpp bp5 tvar5 pexpp_)) pexpp_list)
  | (Ep_constraint cp5) => Ep_constraint cp5
  | (Ep_loop loop5 ep1 ep2) => Ep_loop loop5 (tsubst_ep bp5 tvar5 ep1) (tsubst_ep bp5 tvar5 ep2)
  | (Ep_for id5 ep1 ep2 ep3 order5 ep4) => Ep_for id5 (tsubst_ep bp5 tvar5 ep1) (tsubst_ep bp5 tvar5 ep2) (tsubst_ep bp5 tvar5 ep3) order5 (tsubst_ep bp5 tvar5 ep4)
  | (Ep_assert ep1 ep2) => Ep_assert (tsubst_ep bp5 tvar5 ep1) (tsubst_ep bp5 tvar5 ep2)
  | (Ep_vec ep_list) => Ep_vec (map (fun (ep_:ep) => (tsubst_ep bp5 tvar5 ep_)) ep_list)
  | (Ep_list ep_list) => Ep_list (map (fun (ep_:ep) => (tsubst_ep bp5 tvar5 ep_)) ep_list)
  | (Ep_cons ep1 ep2) => Ep_cons (tsubst_ep bp5 tvar5 ep1) (tsubst_ep bp5 tvar5 ep2)
end
with tsubst_letbindp (bp5:bp) (tvar5:tvar) (letbindp5:letbindp) {struct letbindp5} : letbindp :=
  match letbindp5 with
  | (LBp_val patp5 ep5) => LBp_val (tsubst_patp bp5 tvar5 patp5) (tsubst_ep bp5 tvar5 ep5)
end
with tsubst_pexpp (bp5:bp) (tvar5:tvar) (pexpp_6:pexpp) {struct pexpp_6} : pexpp :=
  match pexpp_6 with
  | (PEXPp_exp patp5 ep5) => PEXPp_exp (tsubst_patp bp5 tvar5 patp5) (tsubst_ep bp5 tvar5 ep5)
  | (PEXPp_when patp5 ep1 ep2) => PEXPp_when (tsubst_patp bp5 tvar5 patp5) (tsubst_ep bp5 tvar5 ep1) (tsubst_ep bp5 tvar5 ep2)
end.

Definition tsubst_ap (bp_6:bp) (tvar5:tvar) (ap5:ap) : ap :=
  match ap5 with
  | (A_monotype tp5) => A_monotype (tsubst_tp bp_6 tvar5 tp5)
  | (A_function xp5 bp5 cp5 tp5) => A_function xp5 (tsubst_bp bp_6 tvar5 bp5) cp5 (tsubst_tp bp_6 tvar5 tp5)
end.

Definition subst_tannot_opt_p (vp5:vp) (zp5:xp) (tannot_opt_p5:tannot_opt_p) : tannot_opt_p :=
  match tannot_opt_p5 with
  | Typ_annot_opt_pnone => Typ_annot_opt_pnone 
  | (Typ_annot_opt_psome klist5 tp5) => Typ_annot_opt_psome klist5 (subst_tp vp5 zp5 tp5)
  | (Typ_annot_opt_psome_fn ap5) => Typ_annot_opt_psome_fn (subst_ap vp5 zp5 ap5)
end.

Definition subst_funclp (vp5:vp) (zp5:xp) (funclp5:funclp) : funclp :=
  match funclp5 with
  | (FCLp_funcl id5 pexpp5) => FCLp_funcl id5 (subst_pexpp vp5 zp5 pexpp5)
end.

Definition tsubst_funclp (bp5:bp) (tvar5:tvar) (funclp5:funclp) : funclp :=
  match funclp5 with
  | (FCLp_funcl id5 pexpp5) => FCLp_funcl id5 (tsubst_pexpp bp5 tvar5 pexpp5)
end.

Definition tsubst_tannot_opt_p (bp5:bp) (tvar5:tvar) (tannot_opt_p5:tannot_opt_p) : tannot_opt_p :=
  match tannot_opt_p5 with
  | Typ_annot_opt_pnone => Typ_annot_opt_pnone 
  | (Typ_annot_opt_psome klist5 tp5) => Typ_annot_opt_psome klist5 (tsubst_tp bp5 tvar5 tp5)
  | (Typ_annot_opt_psome_fn ap5) => Typ_annot_opt_psome_fn (tsubst_ap bp5 tvar5 ap5)
end.

Definition subst_scattered_defp (vp5:vp) (zp5:xp) (scattered_defp5:scattered_defp) : scattered_defp :=
  match scattered_defp5 with
  | (SDp_function tannot_opt_p5 id5) => SDp_function (subst_tannot_opt_p vp5 zp5 tannot_opt_p5) id5
  | (SDp_variant id5 kp_bp_cp_list) => SDp_variant id5 (map (fun (pat_:(xp*bp*cp)) => match pat_ with (kp_,bp_,cp_) => (kp_,(subst_bp vp5 zp5 bp_),(subst_cp vp5 zp5 cp_)) end) kp_bp_cp_list)
  | (SDp_unioncl id1 id2 tp5) => SDp_unioncl id1 id2 (subst_tp vp5 zp5 tp5)
  | (SDp_funclp funclp5) => SDp_funclp (subst_funclp vp5 zp5 funclp5)
  | (SDp_end id5) => SDp_end id5
end.

Definition tsubst_scattered_defp (bp_5:bp) (tvar5:tvar) (scattered_defp5:scattered_defp) : scattered_defp :=
  match scattered_defp5 with
  | (SDp_function tannot_opt_p5 id5) => SDp_function (tsubst_tannot_opt_p bp_5 tvar5 tannot_opt_p5) id5
  | (SDp_variant id5 kp_bp_cp_list) => SDp_variant id5 (map (fun (pat_:(xp*bp*cp)) => match pat_ with (kp_,bp_,cp_) => (kp_,(tsubst_bp bp_5 tvar5 bp_),cp_) end) kp_bp_cp_list)
  | (SDp_unioncl id1 id2 tp5) => SDp_unioncl id1 id2 (tsubst_tp bp_5 tvar5 tp5)
  | (SDp_funclp funclp5) => SDp_funclp (tsubst_funclp bp_5 tvar5 funclp5)
  | (SDp_end id5) => SDp_end id5
end.

Definition subst_defp (vp5:vp) (zp5:xp) (defp5:defp) : defp :=
  match defp5 with
  | (DEFp_fundef ap5 funclp_list) => DEFp_fundef (subst_ap vp5 zp5 ap5) (map (fun (funclp_:funclp) => (subst_funclp vp5 zp5 funclp_)) funclp_list)
  | (DEFp_typedef id5 kp_bp_cp_list tp5) => DEFp_typedef id5 (map (fun (pat_:(xp*bp*cp)) => match pat_ with (kp_,bp_,cp_) => (kp_,(subst_bp vp5 zp5 bp_),(subst_cp vp5 zp5 cp_)) end) kp_bp_cp_list) (subst_tp vp5 zp5 tp5)
  | (DEFp_spec id5 ap5) => DEFp_spec id5 (subst_ap vp5 zp5 ap5)
  | (DEFp_val letbindp5) => DEFp_val (subst_letbindp vp5 zp5 letbindp5)
  | (DEFp_reg tp5 xp5) => DEFp_reg (subst_tp vp5 zp5 tp5) xp5
  | (DEFp_overload id_5 id_list) => DEFp_overload id_5 id_list
  | (DEFp_scattered scattered_defp5) => DEFp_scattered (subst_scattered_defp vp5 zp5 scattered_defp5)
  | (DEFp_default order5) => DEFp_default order5
end.

Definition tsubst_defp (bp_5:bp) (tvar5:tvar) (defp5:defp) : defp :=
  match defp5 with
  | (DEFp_fundef ap5 funclp_list) => DEFp_fundef (tsubst_ap bp_5 tvar5 ap5) (map (fun (funclp_:funclp) => (tsubst_funclp bp_5 tvar5 funclp_)) funclp_list)
  | (DEFp_typedef id5 kp_bp_cp_list tp5) => DEFp_typedef id5 (map (fun (pat_:(xp*bp*cp)) => match pat_ with (kp_,bp_,cp_) => (kp_,(tsubst_bp bp_5 tvar5 bp_),cp_) end) kp_bp_cp_list) (tsubst_tp bp_5 tvar5 tp5)
  | (DEFp_spec id5 ap5) => DEFp_spec id5 (tsubst_ap bp_5 tvar5 ap5)
  | (DEFp_val letbindp5) => DEFp_val (tsubst_letbindp bp_5 tvar5 letbindp5)
  | (DEFp_reg tp5 xp5) => DEFp_reg (tsubst_tp bp_5 tvar5 tp5) xp5
  | (DEFp_overload id_5 id_list) => DEFp_overload id_5 id_list
  | (DEFp_scattered scattered_defp5) => DEFp_scattered (tsubst_scattered_defp bp_5 tvar5 scattered_defp5)
  | (DEFp_default order5) => DEFp_default order5
end.

Definition subst_progp (vp5:vp) (zp5:xp) (progp5:progp) : progp :=
  match progp5 with
  | (Pp_prog defp_list) => Pp_prog (map (fun (defp_:defp) => (subst_defp vp5 zp5 defp_)) defp_list)
end.

Definition tsubst_progp (bp5:bp) (tvar5:tvar) (progp5:progp) : progp :=
  match progp5 with
  | (Pp_prog defp_list) => Pp_prog (map (fun (defp_:defp) => (tsubst_defp bp5 tvar5 defp_)) defp_list)
end.

Fixpoint tsubst_bsub (bp_6:bp) (tvar_6:tvar) (bsub_6:bsub) {struct bsub_6} : bsub :=
  match bsub_6 with
  | BS_empty => BS_empty 
  | (BS_cons bsub5 bp5 tvar5) => BS_cons (tsubst_bsub bp_6 tvar_6 bsub5) (tsubst_bp bp_6 tvar_6 bp5) tvar5
end.

Fixpoint subst_bsub (vp5:vp) (zp5:xp) (bsub_6:bsub) {struct bsub_6} : bsub :=
  match bsub_6 with
  | BS_empty => BS_empty 
  | (BS_cons bsub5 bp5 tvar5) => BS_cons (subst_bsub vp5 zp5 bsub5) (subst_bp vp5 zp5 bp5) tvar5
end.

(** library functions *)
Fixpoint list_minus A (eq:forall a b:A,{a=b}+{a<>b}) (l1:list A) (l2:list A) {struct l1} : list A :=
  match l1 with
  | nil => nil
  | cons h t => if (list_mem (A:=A) eq h l2) then list_minus A eq t l2 else cons h (list_minus A eq t l2)
end.
Implicit Arguments list_minus.


(** free variables *)
Fixpoint fvs_vp (vp_6:vp) : list xp :=
  match vp_6 with
  | (V_lit lit5) => nil
  | (V_var xp5) => (cons xp5 nil)
  | (V_vec vp_list) => ((flat_map (fun (vp_:vp) => (fvs_vp vp_)) vp_list))
  | (V_list vp_list) => ((flat_map (fun (vp_:vp) => (fvs_vp vp_)) vp_list))
  | (V_cons vp1 vp2) => (app (fvs_vp vp1) (fvs_vp vp2))
  | (V_constr ctor5 vp5) => ((fvs_vp vp5))
  | (V_record field_vp_list) => ((flat_map (fun (pat_:(field*vp)) => match pat_ with (field_,vp_) => (fvs_vp vp_) end) field_vp_list))
  | (V_tuple vp_list) => ((flat_map (fun (vp_:vp) => (fvs_vp vp_)) vp_list))
  | (V_proj p5 vp5) => ((fvs_vp vp5))
end.

Fixpoint fvs_cep (cep_6:cep) : list xp :=
  match cep_6 with
  | (CE_val vp5) => ((fvs_vp vp5))
  | (CE_bop cep1 bop5 cep2) => (app (fvs_cep cep1) (fvs_cep cep2))
  | (CE_many_plus cep_list) => ((flat_map (fun (cep_:cep) => (fvs_cep cep_)) cep_list))
  | (CE_uop uop5 cep5) => ((fvs_cep cep5))
  | (CE_proj p5 cep5) => ((fvs_cep cep5))
  | (CE_field_access xp5 field5) => nil
end.

Fixpoint fvs_cp (cp_6:cp) : list xp :=
  match cp_6 with
  | C_true => nil
  | C_false => nil
  | (C_conj cp1 cp2) => (app (fvs_cp cp1) (fvs_cp cp2))
  | (C_conj_many cp_list) => ((flat_map (fun (cp_:cp) => (fvs_cp cp_)) cp_list))
  | (C_disj cp1 cp2) => (app (fvs_cp cp1) (fvs_cp cp2))
  | (C_not cp5) => ((fvs_cp cp5))
  | (C_eq cep1 cep2) => (app (fvs_cep cep1) (fvs_cep cep2))
  | (C_leq cep1 cep2) => (app (fvs_cep cep1) (fvs_cep cep2))
  | (C_imp cp1 cp2) => (app (fvs_cp cp1) (fvs_cp cp2))
end.

Fixpoint fvs_tp (tp_6:tp) : list xp :=
  match tp_6 with
  | (T_refined_type zp bp5 cp5) => (app (fvs_bp bp5) (fvs_cp cp5))
end
with fvs_bp (bp_6:bp) : list xp :=
  match bp_6 with
  | (B_var tvar5) => nil
  | (B_tid id5) => nil
  | B_int => nil
  | B_bool => nil
  | B_bit => nil
  | B_unit => nil
  | B_real => nil
  | (B_vec order5 bp5) => ((fvs_bp bp5))
  | (B_list bp5) => ((fvs_bp bp5))
  | (B_tuple bp_list) => ((flat_map (fun (bp_:bp) => (fvs_bp bp_)) bp_list))
  | (B_union id5 ctor_tp_list) => ((flat_map (fun (pat_:(ctor*tp)) => match pat_ with (ctor_,tp_) => (fvs_tp tp_) end) ctor_tp_list))
  | (B_record field_bp_list) => ((flat_map (fun (pat_:(field*bp)) => match pat_ with (field_,bp_) => (fvs_bp bp_) end) field_bp_list))
  | B_undef => nil
  | B_reg => nil
  | B_string => nil
  | B_exception => nil
  | (B_finite_set num_list) => (nil)
end.

Fixpoint fvs_lexpp (lexpp_6:lexpp) : list xp :=
  match lexpp_6 with
  | (LEXPp_mvar up5) => nil
  | (LEXPp_cast tp5 up5) => ((fvs_tp tp5))
  | (LEXPp_tup lexpp_list) => ((flat_map (fun (lexpp_:lexpp) => (fvs_lexpp lexpp_)) lexpp_list))
  | (LEXPp_field lexpp5 id5) => ((fvs_lexpp lexpp5))
end.

Fixpoint fvs_patp (patp_6:patp) : list xp :=
  match patp_6 with
  | (Pp_lit lit5) => nil
  | Pp_wild => nil
  | (Pp_as_var patp5 xp5) => ((fvs_patp patp5))
  | (Pp_typ tp5 patp5) => (app (fvs_tp tp5) (fvs_patp patp5))
  | (Pp_id id5) => nil
  | (Pp_as_typ patp5 tp5) => (app (fvs_patp patp5) (fvs_tp tp5))
  | (Pp_app id5 patp_list) => ((flat_map (fun (patp_:patp) => (fvs_patp patp_)) patp_list))
  | (Pp_vector patp_list) => ((flat_map (fun (patp_:patp) => (fvs_patp patp_)) patp_list))
  | (Pp_vector_concat patp_list) => ((flat_map (fun (patp_:patp) => (fvs_patp patp_)) patp_list))
  | (Pp_tup patp_list) => ((flat_map (fun (patp_:patp) => (fvs_patp patp_)) patp_list))
  | (Pp_list patp_list) => ((flat_map (fun (patp_:patp) => (fvs_patp patp_)) patp_list))
  | (Pp_cons patp1 patp2) => (app (fvs_patp patp1) (fvs_patp patp2))
  | (Pp_string_append patp_list) => ((flat_map (fun (patp_:patp) => (fvs_patp patp_)) patp_list))
end.

Definition fvs_ap (ap5:ap) : list xp :=
  match ap5 with
  | (A_monotype tp5) => ((fvs_tp tp5))
  | (A_function xp5 bp5 cp5 tp5) => (app (fvs_bp bp5) (app (fvs_cp cp5) (fvs_tp tp5)))
end.

Fixpoint fvs_ep (ep__6:ep) : list xp :=
  match ep__6 with
  | (Ep_val vp5) => ((fvs_vp vp5))
  | (Ep_mvar up5) => nil
  | (Ep_concat ep_list) => ((flat_map (fun (ep_:ep) => (fvs_ep ep_)) ep_list))
  | (Ep_tuple ep_list) => ((flat_map (fun (ep_:ep) => (fvs_ep ep_)) ep_list))
  | (Ep_app fp ep5) => ((fvs_ep ep5))
  | (Ep_bop bop5 ep1 ep2) => (app (fvs_ep ep1) (fvs_ep ep2))
  | (Ep_uop uop5 ep5) => ((fvs_ep ep5))
  | (Ep_proj p5 ep5) => ((fvs_ep ep5))
  | (Ep_constr ctor5 ep5) => ((fvs_ep ep5))
  | (Ep_field_access ep5 field5) => ((fvs_ep ep5))
  | (Ep_sizeof cep5) => ((fvs_cep cep5))
  | (Ep_cast tp5 ep5) => (app (fvs_tp tp5) (fvs_ep ep5))
  | (Ep_record field_ep_list) => ((flat_map (fun (pat_:(field*ep)) => match pat_ with (field_,ep_) => (fvs_ep ep_) end) field_ep_list))
  | (Ep_record_update ep_5 field_ep_list) => (app (fvs_ep ep_5) (flat_map (fun (pat_:(field*ep)) => match pat_ with (field_,ep_) => (fvs_ep ep_) end) field_ep_list))
  | (Ep_let letbindp5 ep2) => (app (fvs_letbindp letbindp5) (fvs_ep ep2))
  | (Ep_let2 xp5 tp5 ep1 ep2) => (app (fvs_tp tp5) (app (fvs_ep ep1) (list_minus eq_xp (fvs_ep ep2) (cons xp5 nil))))
  | (Ep_if ep1 ep2 ep3) => (app (fvs_ep ep1) (app (fvs_ep ep2) (fvs_ep ep3)))
  | (Ep_block ep_list) => ((flat_map (fun (ep_:ep) => (fvs_ep ep_)) ep_list))
  | (Ep_case ep5 pexpp_list) => (app (fvs_ep ep5) (flat_map (fun (pexpp_:pexpp) => (fvs_pexpp pexpp_)) pexpp_list))
  | (Ep_assign lexpp5 ep1 ep2) => (app (fvs_lexpp lexpp5) (app (fvs_ep ep1) (fvs_ep ep2)))
  | (Ep_exit ep5) => ((fvs_ep ep5))
  | (Ep_return ep5) => ((fvs_ep ep5))
  | (Ep_throw ep5) => ((fvs_ep ep5))
  | (Ep_try ep5 pexpp_list) => (app (fvs_ep ep5) (flat_map (fun (pexpp_:pexpp) => (fvs_pexpp pexpp_)) pexpp_list))
  | (Ep_constraint cp5) => ((fvs_cp cp5))
  | (Ep_loop loop5 ep1 ep2) => (app (fvs_ep ep1) (fvs_ep ep2))
  | (Ep_for id5 ep1 ep2 ep3 order5 ep4) => (app (fvs_ep ep1) (app (fvs_ep ep2) (app (fvs_ep ep3) (fvs_ep ep4))))
  | (Ep_assert ep1 ep2) => (app (fvs_ep ep1) (fvs_ep ep2))
  | (Ep_vec ep_list) => ((flat_map (fun (ep_:ep) => (fvs_ep ep_)) ep_list))
  | (Ep_list ep_list) => ((flat_map (fun (ep_:ep) => (fvs_ep ep_)) ep_list))
  | (Ep_cons ep1 ep2) => (app (fvs_ep ep1) (fvs_ep ep2))
end
with fvs_letbindp (letbindp5:letbindp) : list xp :=
  match letbindp5 with
  | (LBp_val patp5 ep5) => (app (fvs_patp patp5) (fvs_ep ep5))
end
with fvs_pexpp (pexpp_6:pexpp) : list xp :=
  match pexpp_6 with
  | (PEXPp_exp patp5 ep5) => (app (fvs_patp patp5) (fvs_ep ep5))
  | (PEXPp_when patp5 ep1 ep2) => (app (fvs_patp patp5) (app (fvs_ep ep1) (fvs_ep ep2)))
end.

Definition fvs_tannot_opt_p (tannot_opt_p5:tannot_opt_p) : list xp :=
  match tannot_opt_p5 with
  | Typ_annot_opt_pnone => nil
  | (Typ_annot_opt_psome klist5 tp5) => ((fvs_tp tp5))
  | (Typ_annot_opt_psome_fn ap5) => ((fvs_ap ap5))
end.

Definition fvs_funclp (funclp5:funclp) : list xp :=
  match funclp5 with
  | (FCLp_funcl id5 pexpp5) => ((fvs_pexpp pexpp5))
end.

Definition fvs_scattered_defp (scattered_defp5:scattered_defp) : list xp :=
  match scattered_defp5 with
  | (SDp_function tannot_opt_p5 id5) => ((fvs_tannot_opt_p tannot_opt_p5))
  | (SDp_variant id5 kp_bp_cp_list) => ((flat_map (fun (pat_:(xp*bp*cp)) => match pat_ with (kp_,bp_,cp_) => (fvs_bp bp_) ++ (fvs_cp cp_) end) kp_bp_cp_list))
  | (SDp_unioncl id1 id2 tp5) => ((fvs_tp tp5))
  | (SDp_funclp funclp5) => ((fvs_funclp funclp5))
  | (SDp_end id5) => nil
end.

Definition fvs_defp (defp5:defp) : list xp :=
  match defp5 with
  | (DEFp_fundef ap5 funclp_list) => (app (fvs_ap ap5) (flat_map (fun (funclp_:funclp) => (fvs_funclp funclp_)) funclp_list))
  | (DEFp_typedef id5 kp_bp_cp_list tp5) => (app (flat_map (fun (pat_:(xp*bp*cp)) => match pat_ with (kp_,bp_,cp_) => (fvs_bp bp_) ++ (fvs_cp cp_) end) kp_bp_cp_list) (fvs_tp tp5))
  | (DEFp_spec id5 ap5) => ((fvs_ap ap5))
  | (DEFp_val letbindp5) => ((fvs_letbindp letbindp5))
  | (DEFp_reg tp5 xp5) => ((fvs_tp tp5))
  | (DEFp_overload id_5 id_list) => (nil)
  | (DEFp_scattered scattered_defp5) => ((fvs_scattered_defp scattered_defp5))
  | (DEFp_default order5) => nil
end.

Definition fvs_progp (progp5:progp) : list xp :=
  match progp5 with
  | (Pp_prog defp_list) => ((flat_map (fun (defp_:defp) => (fvs_defp defp_)) defp_list))
end.

Fixpoint fvs_bsub (bsub_6:bsub) : list xp :=
  match bsub_6 with
  | BS_empty => nil
  | (BS_cons bsub5 bp5 tvar5) => (app (fvs_bsub bsub5) (fvs_bp bp5))
end.



