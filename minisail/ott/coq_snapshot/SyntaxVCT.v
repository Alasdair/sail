(* generated by Ott 0.28 from: minisailplus_ast_vct.ott common.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Definition id := nat. (*r Identifiers *)
Lemma eq_id: forall (x y : id), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_id : ott_coq_equality.

Inductive lit : Set :=  (*r Literal constant *)
 | L_unit : lit
 | L_zero : lit
 | L_one : lit
 | L_true : lit
 | L_false : lit
 | L_num (num5:nat) (*r natural number constant *)
 | L_string (string_val5:nat) (*r string constant *)
 | L_undef : lit (*r undefined-value constant *)
 | L_real (real_val5:nat).

Inductive order : Set :=  (*r Vector order specification *)
 | Ord_inc : order
 | Ord_dec : order
 | Ord_def : order (*r default order *).

Inductive loop : Set :=  (*r Loop variant *)
 | loopWhile : loop
 | loopUntil : loop.
Definition tvar := nat. (*r Base-type variable *)
Lemma eq_tvar: forall (x y : tvar), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_tvar : ott_coq_equality.
Definition ctor := nat. (*r Constructor *)
Lemma eq_ctor: forall (x y : ctor), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_ctor : ott_coq_equality.
Definition field := nat. (*r Record Field *)
Lemma eq_field: forall (x y : field), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_field : ott_coq_equality.

Inductive xp : Set :=  (*r Immutable variables incl. function names *)
 | VNamed (id5:id) (*r general variable *)
 | VIndex : xp (*r value variable bound in refinement type *).

Inductive vp : Set :=  (*r Values *)
 | V_lit (lit5:lit)
 | V_var (xp5:xp)
 | V_vec (_:list vp) (*r vector *)
 | V_list (_:list vp)
 | V_cons (vp1:vp) (vp2:vp) (*r list cons *)
 | V_constr (ctor5:ctor) (vp5:vp) (*r union constructor *)
 | V_record (_:list (field*vp)) (*r record *)
 | V_tuple (_:list vp) (*r tuple *)
 | V_proj (p5:nat) (vp5:vp) (*r tuple projection *).

Inductive uop : Set :=  (*r Unary operators *)
 | Len : uop (*r vector length *)
 | Exp : uop (*r base 2 exponent *)
 | Neg : uop (*r negation *)
 | Not : uop (*r boolean not *).

Inductive bop : Set :=  (*r Binary operators *)
 | Plus : bop
 | Minus : bop
 | Times : bop
 | Div : bop
 | Mod : bop
 | LEq : bop
 | LT : bop
 | GT : bop
 | GEq : bop
 | Eq : bop
 | And : bop
 | Or : bop
 | NEq : bop.

Inductive cep : Set :=  (*r Constraint expression *)
 | CE_val (vp5:vp)
 | CE_bop (cep1:cep) (bop5:bop) (cep2:cep)
 | CE_many_plus (_:list cep)
 | CE_uop (uop5:uop) (cep5:cep)
 | CE_proj (p5:nat) (cep5:cep) (*r tuple projection *)
 | CE_field_access (xp5:xp) (field5:field) (*r field access *).

Inductive cp : Set :=  (*r Refinement Constraints - Quantifier free logic of uninterpreted functions and linear arithmetic *)
 | C_true : cp
 | C_false : cp
 | C_conj (cp1:cp) (cp2:cp)
 | C_conj_many (_:list cp)
 | C_disj (cp1:cp) (cp2:cp)
 | C_not (cp5:cp)
 | C_eq (cep1:cep) (cep2:cep)
 | C_leq (cep1:cep) (cep2:cep)
 | C_imp (cp1:cp) (cp2:cp).

Inductive bp : Set :=  (*r Base Type *)
 | B_var (tvar5:tvar) (*r type variable *)
 | B_tid (id5:id) (*r type identifier *)
 | B_int : bp
 | B_bool : bp
 | B_bit : bp
 | B_unit : bp
 | B_real : bp
 | B_vec (order5:order) (bp5:bp) (*r vector (length is part of constraint) *)
 | B_list (bp5:bp) (*r list *)
 | B_tuple (_:list bp) (*r tuple *)
 | B_union (id5:id) (_:list (ctor*tp)) (*r union *)
 | B_record (_:list (field*bp)) (*r record *)
 | B_undef : bp
 | B_reg : bp (*r register *)
 | B_string : bp
 | B_exception : bp
 | B_finite_set (_:list nat) (*r finite set of integers *)
with tp : Set :=  (*r Refinement type *)
 | T_refined_type (zp:xp) (bp5:bp) (cp5:cp).

Inductive ap : Set :=  (*r Dependent Function and Monotype Type. Unlike Sail we distinguish in the syntax
function type from monotypes *)
 | A_monotype (tp5:tp)
 | A_function (xp5:xp) (bp5:bp) (cp5:cp) (tp5:tp).

Inductive bsub : Set :=  (*r Substitution for base types *)
 | BS_empty : bsub
 | BS_cons (bsub5:bsub) (bp5:bp) (tvar5:tvar).
Lemma eq_xp: forall (x y : xp), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_xp : ott_coq_equality.
(** induction principles *)
Section tp_bp_rect.

Variables
  (P_tp : tp -> Prop)
  (P_bp : bp -> Prop)
  (P_list_bp : list bp -> Prop)
  (P_list_ctor_tp : list (ctor*tp) -> Prop)
  (P_list_field_bp : list (field*bp) -> Prop).

Hypothesis
  (H_T_refined_type : forall (zp:xp), forall (bp5:bp), P_bp bp5 -> forall (cp5:cp), P_tp (T_refined_type zp bp5 cp5))
  (H_B_var : forall (tvar5:tvar), P_bp (B_var tvar5))
  (H_B_tid : forall (id5:id), P_bp (B_tid id5))
  (H_B_int : P_bp B_int)
  (H_B_bool : P_bp B_bool)
  (H_B_bit : P_bp B_bit)
  (H_B_unit : P_bp B_unit)
  (H_B_real : P_bp B_real)
  (H_B_vec : forall (order5:order), forall (bp5:bp), P_bp bp5 -> P_bp (B_vec order5 bp5))
  (H_B_list : forall (bp5:bp), P_bp bp5 -> P_bp (B_list bp5))
  (H_B_tuple : forall (bp_list:list bp), P_list_bp bp_list -> P_bp (B_tuple bp_list))
  (H_B_union : forall (ctor_tp_list:list (ctor*tp)), P_list_ctor_tp ctor_tp_list -> forall (id5:id), P_bp (B_union id5 ctor_tp_list))
  (H_B_record : forall (field_bp_list:list (field*bp)), P_list_field_bp field_bp_list -> P_bp (B_record field_bp_list))
  (H_B_undef : P_bp B_undef)
  (H_B_reg : P_bp B_reg)
  (H_B_string : P_bp B_string)
  (H_B_exception : P_bp B_exception)
  (H_B_finite_set : forall (num_list:list nat), P_bp (B_finite_set num_list))
  (H_list_bp_nil : P_list_bp nil)
  (H_list_bp_cons : forall (bp0:bp), P_bp bp0 -> forall (bp_l:list bp), P_list_bp bp_l -> P_list_bp (cons bp0 bp_l))
  (H_list_ctor_tp_nil : P_list_ctor_tp nil)
  (H_list_ctor_tp_cons : forall (ctor0:ctor), forall (tp0:tp), P_tp tp0 -> forall (ctor_tp_l:list (ctor*tp)), P_list_ctor_tp ctor_tp_l -> P_list_ctor_tp (cons (ctor0,tp0) ctor_tp_l))
  (H_list_field_bp_nil : P_list_field_bp nil)
  (H_list_field_bp_cons : forall (field0:field), forall (bp1:bp), P_bp bp1 -> forall (field_bp_l:list (field*bp)), P_list_field_bp field_bp_l -> P_list_field_bp (cons (field0,bp1) field_bp_l)).

Fixpoint bp_ott_ind (n:bp) : P_bp n :=
  match n as x return P_bp x with
  | (B_var tvar5) => H_B_var tvar5
  | (B_tid id5) => H_B_tid id5
  | B_int => H_B_int 
  | B_bool => H_B_bool 
  | B_bit => H_B_bit 
  | B_unit => H_B_unit 
  | B_real => H_B_real 
  | (B_vec order5 bp5) => H_B_vec order5 bp5 (bp_ott_ind bp5)
  | (B_list bp5) => H_B_list bp5 (bp_ott_ind bp5)
  | (B_tuple bp_list) => H_B_tuple bp_list (((fix bp_list_ott_ind (bp_l:list bp) : P_list_bp bp_l := match bp_l as x return P_list_bp x with nil => H_list_bp_nil | cons bp2 xl => H_list_bp_cons bp2(bp_ott_ind bp2)xl (bp_list_ott_ind xl) end)) bp_list)
  | (B_union id5 ctor_tp_list) => H_B_union ctor_tp_list (((fix ctor_tp_list_ott_ind (ctor_tp_l:list (ctor*tp)) : P_list_ctor_tp ctor_tp_l := match ctor_tp_l as x return P_list_ctor_tp x with nil => H_list_ctor_tp_nil | cons (ctor1,tp1) xl => H_list_ctor_tp_cons ctor1  tp1(tp_ott_ind tp1)xl (ctor_tp_list_ott_ind xl) end)) ctor_tp_list) id5
  | (B_record field_bp_list) => H_B_record field_bp_list (((fix field_bp_list_ott_ind (field_bp_l:list (field*bp)) : P_list_field_bp field_bp_l := match field_bp_l as x return P_list_field_bp x with nil => H_list_field_bp_nil | cons (field1,bp3) xl => H_list_field_bp_cons field1  bp3(bp_ott_ind bp3)xl (field_bp_list_ott_ind xl) end)) field_bp_list)
  | B_undef => H_B_undef 
  | B_reg => H_B_reg 
  | B_string => H_B_string 
  | B_exception => H_B_exception 
  | (B_finite_set num_list) => H_B_finite_set num_list
end
with tp_ott_ind (n:tp) : P_tp n :=
  match n as x return P_tp x with
  | (T_refined_type zp bp5 cp5) => H_T_refined_type zp bp5 (bp_ott_ind bp5) cp5
end.

End tp_bp_rect.


Section cep_rect.

Variables
  (P_list_cep : list cep -> Prop)
  (P_cep : cep -> Prop).

Hypothesis
  (H_CE_val : forall (vp5:vp), P_cep (CE_val vp5))
  (H_CE_bop : forall (cep1:cep), P_cep cep1 -> forall (bop5:bop), forall (cep2:cep), P_cep cep2 -> P_cep (CE_bop cep1 bop5 cep2))
  (H_CE_many_plus : forall (cep_list:list cep), P_list_cep cep_list -> P_cep (CE_many_plus cep_list))
  (H_CE_uop : forall (uop5:uop), forall (cep5:cep), P_cep cep5 -> P_cep (CE_uop uop5 cep5))
  (H_CE_proj : forall (p5:nat), forall (cep5:cep), P_cep cep5 -> P_cep (CE_proj p5 cep5))
  (H_CE_field_access : forall (xp5:xp), forall (field5:field), P_cep (CE_field_access xp5 field5))
  (H_list_cep_nil : P_list_cep nil)
  (H_list_cep_cons : forall (cep0:cep), P_cep cep0 -> forall (cep_l:list cep), P_list_cep cep_l -> P_list_cep (cons cep0 cep_l)).

Fixpoint cep_ott_ind (n:cep) : P_cep n :=
  match n as x return P_cep x with
  | (CE_val vp5) => H_CE_val vp5
  | (CE_bop cep1 bop5 cep2) => H_CE_bop cep1 (cep_ott_ind cep1) bop5 cep2 (cep_ott_ind cep2)
  | (CE_many_plus cep_list) => H_CE_many_plus cep_list (((fix cep_list_ott_ind (cep_l:list cep) : P_list_cep cep_l := match cep_l as x return P_list_cep x with nil => H_list_cep_nil | cons cep1 xl => H_list_cep_cons cep1(cep_ott_ind cep1)xl (cep_list_ott_ind xl) end)) cep_list)
  | (CE_uop uop5 cep5) => H_CE_uop uop5 cep5 (cep_ott_ind cep5)
  | (CE_proj p5 cep5) => H_CE_proj p5 cep5 (cep_ott_ind cep5)
  | (CE_field_access xp5 field5) => H_CE_field_access xp5 field5
end.

End cep_rect.


Section cp_rect.

Variables
  (P_list_cp : list cp -> Prop)
  (P_cp : cp -> Prop).

Hypothesis
  (H_C_true : P_cp C_true)
  (H_C_false : P_cp C_false)
  (H_C_conj : forall (cp1:cp), P_cp cp1 -> forall (cp2:cp), P_cp cp2 -> P_cp (C_conj cp1 cp2))
  (H_C_conj_many : forall (cp_list:list cp), P_list_cp cp_list -> P_cp (C_conj_many cp_list))
  (H_C_disj : forall (cp1:cp), P_cp cp1 -> forall (cp2:cp), P_cp cp2 -> P_cp (C_disj cp1 cp2))
  (H_C_not : forall (cp5:cp), P_cp cp5 -> P_cp (C_not cp5))
  (H_C_eq : forall (cep1:cep), forall (cep2:cep), P_cp (C_eq cep1 cep2))
  (H_C_leq : forall (cep1:cep), forall (cep2:cep), P_cp (C_leq cep1 cep2))
  (H_C_imp : forall (cp1:cp), P_cp cp1 -> forall (cp2:cp), P_cp cp2 -> P_cp (C_imp cp1 cp2))
  (H_list_cp_nil : P_list_cp nil)
  (H_list_cp_cons : forall (cp0:cp), P_cp cp0 -> forall (cp_l:list cp), P_list_cp cp_l -> P_list_cp (cons cp0 cp_l)).

Fixpoint cp_ott_ind (n:cp) : P_cp n :=
  match n as x return P_cp x with
  | C_true => H_C_true 
  | C_false => H_C_false 
  | (C_conj cp1 cp2) => H_C_conj cp1 (cp_ott_ind cp1) cp2 (cp_ott_ind cp2)
  | (C_conj_many cp_list) => H_C_conj_many cp_list (((fix cp_list_ott_ind (cp_l:list cp) : P_list_cp cp_l := match cp_l as x return P_list_cp x with nil => H_list_cp_nil | cons cp1 xl => H_list_cp_cons cp1(cp_ott_ind cp1)xl (cp_list_ott_ind xl) end)) cp_list)
  | (C_disj cp1 cp2) => H_C_disj cp1 (cp_ott_ind cp1) cp2 (cp_ott_ind cp2)
  | (C_not cp5) => H_C_not cp5 (cp_ott_ind cp5)
  | (C_eq cep1 cep2) => H_C_eq cep1 cep2
  | (C_leq cep1 cep2) => H_C_leq cep1 cep2
  | (C_imp cp1 cp2) => H_C_imp cp1 (cp_ott_ind cp1) cp2 (cp_ott_ind cp2)
end.

End cp_rect.


Section vp_rect.

Variables
  (P_list_field_vp : list (field*vp) -> Prop)
  (P_list_vp : list vp -> Prop)
  (P_vp : vp -> Prop).

Hypothesis
  (H_V_lit : forall (lit5:lit), P_vp (V_lit lit5))
  (H_V_var : forall (xp5:xp), P_vp (V_var xp5))
  (H_V_vec : forall (vp_list:list vp), P_list_vp vp_list -> P_vp (V_vec vp_list))
  (H_V_list : forall (vp_list:list vp), P_list_vp vp_list -> P_vp (V_list vp_list))
  (H_V_cons : forall (vp1:vp), P_vp vp1 -> forall (vp2:vp), P_vp vp2 -> P_vp (V_cons vp1 vp2))
  (H_V_constr : forall (ctor5:ctor), forall (vp5:vp), P_vp vp5 -> P_vp (V_constr ctor5 vp5))
  (H_V_record : forall (field_vp_list:list (field*vp)), P_list_field_vp field_vp_list -> P_vp (V_record field_vp_list))
  (H_V_tuple : forall (vp_list:list vp), P_list_vp vp_list -> P_vp (V_tuple vp_list))
  (H_V_proj : forall (p5:nat), forall (vp5:vp), P_vp vp5 -> P_vp (V_proj p5 vp5))
  (H_list_field_vp_nil : P_list_field_vp nil)
  (H_list_field_vp_cons : forall (field0:field), forall (vp0:vp), P_vp vp0 -> forall (field_vp_l:list (field*vp)), P_list_field_vp field_vp_l -> P_list_field_vp (cons (field0,vp0) field_vp_l))
  (H_list_vp_nil : P_list_vp nil)
  (H_list_vp_cons : forall (vp1:vp), P_vp vp1 -> forall (vp_l:list vp), P_list_vp vp_l -> P_list_vp (cons vp1 vp_l)).

Fixpoint vp_ott_ind (n:vp) : P_vp n :=
  match n as x return P_vp x with
  | (V_lit lit5) => H_V_lit lit5
  | (V_var xp5) => H_V_var xp5
  | (V_vec vp_list) => H_V_vec vp_list (((fix vp_list_ott_ind (vp_l:list vp) : P_list_vp vp_l := match vp_l as x return P_list_vp x with nil => H_list_vp_nil | cons vp2 xl => H_list_vp_cons vp2(vp_ott_ind vp2)xl (vp_list_ott_ind xl) end)) vp_list)
  | (V_list vp_list) => H_V_list vp_list (((fix vp_list_ott_ind (vp_l:list vp) : P_list_vp vp_l := match vp_l as x return P_list_vp x with nil => H_list_vp_nil | cons vp3 xl => H_list_vp_cons vp3(vp_ott_ind vp3)xl (vp_list_ott_ind xl) end)) vp_list)
  | (V_cons vp1 vp2) => H_V_cons vp1 (vp_ott_ind vp1) vp2 (vp_ott_ind vp2)
  | (V_constr ctor5 vp5) => H_V_constr ctor5 vp5 (vp_ott_ind vp5)
  | (V_record field_vp_list) => H_V_record field_vp_list (((fix field_vp_list_ott_ind (field_vp_l:list (field*vp)) : P_list_field_vp field_vp_l := match field_vp_l as x return P_list_field_vp x with nil => H_list_field_vp_nil | cons (field1,vp4) xl => H_list_field_vp_cons field1  vp4(vp_ott_ind vp4)xl (field_vp_list_ott_ind xl) end)) field_vp_list)
  | (V_tuple vp_list) => H_V_tuple vp_list (((fix vp_list_ott_ind (vp_l:list vp) : P_list_vp vp_l := match vp_l as x return P_list_vp x with nil => H_list_vp_nil | cons vp5 xl => H_list_vp_cons vp5(vp_ott_ind vp5)xl (vp_list_ott_ind xl) end)) vp_list)
  | (V_proj p5 vp5) => H_V_proj p5 vp5 (vp_ott_ind vp5)
end.

End vp_rect.


