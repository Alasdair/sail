(* generated by Ott 0.28 from: minisailplus_ast_vct.ott common.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Require Import SyntaxVCT.
Require Import SyntaxPED.






Inductive Gamma : Set :=
    | G_empty
    | G_cons (G : Gamma ) (xp:xp) (bp:bp) (cp:cp).

Definition xlist : Set := list xp.

(** Not sure why this is needed. We mapped num to nat in common and it works in other Ott files *)
Definition num : Set := nat.

Inductive Theta : Set :=
   | TEmpty
   | TCons ( T : Theta ) (defp : defp ).

Inductive Phi : Set :=
   | PEmpty
   | PCons ( P : Phi ) ( defp : defp ).

Inductive Delta : Set :=
   | DEmpty
   | DCons ( D : Delta ) ( up : up ) ( tp : tp ).



(** Stubs but should be easy to implement. Decisions will need to be made as to how to handle
    entries with the same key *)

(* IMPORTANT: This is the gateway to the SMT checker. A mechanisation will need to handle this *)
Inductive valid : Theta -> Gamma -> cp -> Prop :=
  | valid_true : forall (T:Theta) (G:Gamma) , valid T G C_true .


Fixpoint unify_b ( bp1 : bp ) (bp2 : bp ) : option bsub := Some BS_empty.

Inductive sublist : list nat -> list nat -> Prop :=
  | sublist_eq : forall (num_list1 : list nat ) (num_list2 : list nat ) , num_list1 = num_list1 -> sublist num_list1 num_list2.


Fixpoint mk_fresh ( G : Gamma ) : xp := VIndex .

Fixpoint single_base ( b : list bp ) : option bp := None .

Fixpoint mk_ctor_v ( _ : nat ) ( _ : list xp ) : option vp := None .

Fixpoint b_of_many ( tp_list : list tp ) : list bp := nil .

Fixpoint tsubst_bp_many ( bp : bp ) (bsub : bsub ) := bp .

Fixpoint add_vars_many ( G : Gamma ) (list_klist : list klist) := G.

Fixpoint mk_proj_vars ( _ : xp ) ( _ : list bp ) : (list xp * klist ) := ( nil , nil ) .

Fixpoint klist_concat (l : list klist) : klist :=
   match l with
     | nil => nil
       | cons x l => x ++ klist_concat l
         end.

Fixpoint lookup_types_for ( _ : bp ) ( _ : list field ) : option (list bp) := None .

Inductive  check_vars : Gamma -> list xp  -> Prop :=  | check_varsI : forall ( G : Gamma ) (xp_list : list xp ), check_vars G xp_list . 


(* Functions for getting and setting things in the various contexts *)



(* Theta. Type definitions *)

Fixpoint lookup_ctor_base ( T : Theta) (c : ctor) : option (tp*bp) := None .

Fixpoint lookup_constr_union_type ( T : Theta) (c : ctor) : option (tp*tp) := None .

Fixpoint add_type ( T : Theta ) ( _ : xp ) ( _ : tp ) : Theta := T .

Fixpoint lookup_field_record_type ( _ : Theta ) ( _ : nat ) : option (bp*tp) := None .

Fixpoint lookup_field_and_record_type ( _ : Theta ) ( _ : up ) : option (tp*tp) := None .

Fixpoint lookup_fields ( _ : Theta ) ( _ : list field ) : option tp := None .

Fixpoint lookup_fun_type ( _ : Theta ) ( _ : Phi ) ( _ : xp ) : option (list ap) := None .

Fixpoint default_order ( T : Theta ) : option order := None .

Fixpoint set_order ( T : Theta ) ( _ : order ) : Theta := T .


(* Phi. Function definitions *)

Fixpoint lookup_fun  ( _ : Phi ) ( _ : xp ) : option (list ap) := None .

Fixpoint add_fun ( P : Phi ) ( _ : (xp*ap*(option funclp)))  : Phi := P . 

Fixpoint add_fun_all ( P : Phi ) ( _ : ap ) ( _ : list funclp ) : Phi := P . 

Fixpoint add_to_overload ( P : Phi ) ( _ : xp ) ( _ : list xp  ) : Phi := P . 


(* Gamma. Immutable variable context *)

Fixpoint lookup_var ( G : Gamma) (xp : xp) : option (bp*cp) := None .

(* return type of the function body that is being checked *)
Fixpoint add_return ( G : Gamma ) ( _ : tp ) : Gamma := G . 

Fixpoint lookup_return  ( _ : Gamma )  : option tp := None .



(* Delta. Mutable variable context *)

Fixpoint lookup_mvar ( _ : Delta ) ( _ : up ) : option tp := None .

Fixpoint add_mvar ( D : Delta ) ( _ : up*tp ) : Delta := D .

Fixpoint update_mvar ( D : Delta ) ( _ : up*tp ) : Delta := D .




(** definitions *)

(* defns subtyping *)
Inductive subtype_base : Theta -> bp -> bp -> Prop :=    (* defn subtype_base *)
 | subtype_base_refl : forall (T5:Theta) (bp1 bp2:bp) (bsub5:bsub),
      (Some  bsub5  = unify_b  bp1   bp2 )  ->
     subtype_base T5 bp1 bp2
 | subtype_base_finite_set_SUBSET : forall (num'_list num_list:list nat) (T5:Theta),
      sublist  num_list   num'_list  ->
     subtype_base T5 (B_finite_set num_list) (B_finite_set num'_list)
 | subtype_base_finite_set_int : forall (num_list:list nat) (T5:Theta),
     subtype_base T5 (B_finite_set num_list) B_int
with subtype : Theta -> Gamma -> tp -> tp -> Prop :=    (* defn subtype *)
 | subtype_subtype : forall (T5:Theta) (Gamma5:Gamma) (zp1:xp) (bp1:bp) (cp1:cp) (zp2:xp) (bp2:bp) (cp2:cp) (xp5:xp),
     subtype_base T5 bp1 bp2 ->
      (  xp5  = mk_fresh  Gamma5  )  ->
      valid  T5   (G_cons Gamma5 xp5 bp1  (subst_cp  (V_var xp5)   zp1   cp1  ) )    (subst_cp  (V_var xp5)   zp2   cp2  )   ->
     subtype T5 Gamma5 (T_refined_type zp1 bp1 cp1) (T_refined_type zp2 bp2 cp2).
(** definitions *)

(* defns typing_v *)
Inductive infer_v : Theta -> Gamma -> vp -> tp -> Prop :=    (* defn infer_v *)
 | infer_v_var : forall (T5:Theta) (Gamma5:Gamma) (xp5:xp) (bp5:bp) (cp5:cp),
      (Some ( bp5 ,  cp5 ) = lookup_var  Gamma5   xp5 )  ->
     infer_v T5 Gamma5 (V_var xp5) (T_refined_type VIndex bp5  (subst_cp  (V_var VIndex)   xp5   cp5  ) )
 | infer_v_true : forall (T5:Theta) (Gamma5:Gamma) (xp5:xp),
      (  xp5  = mk_fresh  Gamma5  )  ->
     infer_v T5 Gamma5 (V_lit L_true) (T_refined_type VIndex B_bool (C_eq (CE_val (V_var VIndex)) (CE_val (V_lit L_true))))
 | infer_v_false : forall (T5:Theta) (Gamma5:Gamma) (xp5:xp),
      (  xp5  = mk_fresh  Gamma5  )  ->
     infer_v T5 Gamma5 (V_lit L_false) (T_refined_type VIndex B_bool (C_eq (CE_val (V_var VIndex)) (CE_val (V_lit L_false))))
 | infer_v_num : forall (T5:Theta) (Gamma5:Gamma) (num5:nat) (xp5:xp),
      (  xp5  = mk_fresh  Gamma5  )  ->
     infer_v T5 Gamma5 (V_lit (L_num num5)) (T_refined_type VIndex B_int (C_eq (CE_val (V_var VIndex)) (CE_val (V_lit (L_num num5)))))
 | infer_v_bitone : forall (T5:Theta) (Gamma5:Gamma) (xp5:xp),
      (  xp5  = mk_fresh  Gamma5  )  ->
     infer_v T5 Gamma5 (V_lit L_one) (T_refined_type VIndex B_bit (C_eq (CE_val (V_var VIndex)) (CE_val (V_lit L_one))))
 | infer_v_bitzero : forall (T5:Theta) (Gamma5:Gamma) (xp5:xp),
      (  xp5  = mk_fresh  Gamma5  )  ->
     infer_v T5 Gamma5 (V_lit L_zero) (T_refined_type VIndex B_bit (C_eq (CE_val (V_var VIndex)) (CE_val (V_lit L_zero))))
 | infer_v_unit : forall (T5:Theta) (Gamma5:Gamma) (xp5:xp),
      (  xp5  = mk_fresh  Gamma5  )  ->
     infer_v T5 Gamma5 (V_lit L_unit) (T_refined_type VIndex B_unit (C_eq (CE_val (V_var VIndex)) (CE_val (V_lit L_unit))))
 | infer_v_bitvec : forall (vp_zp_bp_cp_list:list (vp*xp*bp*cp)) (T5:Theta) (Gamma5:Gamma) (order5:order) (bp_5:bp),
     (forall vp_ zp_ bp_ cp_, In (vp_,zp_,bp_,cp_) (map (fun (pat_: (vp*xp*bp*cp)) => match pat_ with (vp_,zp_,bp_,cp_) => (vp_,zp_,bp_,cp_) end) vp_zp_bp_cp_list) -> (infer_v T5 Gamma5 vp_ (T_refined_type zp_ bp_ cp_))) ->
      (Some  bp_5  = single_base  (map (fun (pat_:(vp*xp*bp*cp)) => match pat_ with (vp_,zp_,bp_,cp_) => bp_ end ) vp_zp_bp_cp_list) )  ->
      (Some  order5  = default_order  T5 )  ->
     infer_v T5 Gamma5 (V_vec (map (fun (pat_:(vp*xp*bp*cp)) => match pat_ with (vp_,zp_,bp_,cp_) => vp_ end ) vp_zp_bp_cp_list)) (T_refined_type VIndex (B_vec order5 bp_5) (C_eq (CE_val (V_var VIndex)) (CE_val (V_vec (map (fun (pat_:(vp*xp*bp*cp)) => match pat_ with (vp_,zp_,bp_,cp_) => vp_ end ) vp_zp_bp_cp_list)))))
 | infer_v_tuple : forall (vp_bp_tp_list:list (vp*bp*tp)) (T5:Theta) (Gamma5:Gamma),
     (forall vp_ tp_, In (vp_,tp_) (map (fun (pat_: (vp*bp*tp)) => match pat_ with (vp_,bp_,tp_) => (vp_,tp_) end) vp_bp_tp_list) -> (infer_v T5 Gamma5 vp_ tp_)) ->
      ( (map (fun (pat_:(vp*bp*tp)) => match pat_ with (vp_,bp_,tp_) => bp_ end ) vp_bp_tp_list)  = b_of_many  (map (fun (pat_:(vp*bp*tp)) => match pat_ with (vp_,bp_,tp_) => tp_ end ) vp_bp_tp_list) )  ->
     infer_v T5 Gamma5 (V_tuple (map (fun (pat_:(vp*bp*tp)) => match pat_ with (vp_,bp_,tp_) => vp_ end ) vp_bp_tp_list)) (T_refined_type VIndex (B_tuple (map (fun (pat_:(vp*bp*tp)) => match pat_ with (vp_,bp_,tp_) => bp_ end ) vp_bp_tp_list)) (C_eq (CE_val (V_var VIndex)) (CE_val (V_tuple (map (fun (pat_:(vp*bp*tp)) => match pat_ with (vp_,bp_,tp_) => vp_ end ) vp_bp_tp_list)))))
 | infer_v_list_cons : forall (T5:Theta) (Gamma5:Gamma) (vp1 vp2:vp) (bp5:bp) (xp5 zp:xp) (cp1 cp2:cp),
      (  xp5  = mk_fresh  Gamma5  )  ->
     infer_v T5 Gamma5 vp1 (T_refined_type zp bp5 cp1) ->
     infer_v T5 Gamma5 vp2 (T_refined_type zp (B_list bp5) cp2) ->
     infer_v T5 Gamma5 (V_cons vp1 vp2) (T_refined_type VIndex (B_list bp5) (C_eq (CE_val (V_var VIndex)) (CE_val (V_cons vp1 vp2))))
 | infer_v_constr : forall (T5:Theta) (Gamma5:Gamma) (ctor5:ctor) (vp5:vp) (zp:xp) (bp_5:bp) (bsub5:bsub) (bp2:bp) (cp2:cp) (bp1:bp) (cp1:cp),
      Some ( (T_refined_type zp bp2 cp2) ,  bp_5 ) = lookup_ctor_base  T5   ctor5  ->
     infer_v T5 Gamma5 vp5 (T_refined_type zp bp1 cp1) ->
      Some  bsub5  = unify_b   bp1   bp2  ->
     subtype T5 Gamma5 (T_refined_type zp  (tsubst_bp_many  bp1   bsub5 )  cp1) (T_refined_type zp  (tsubst_bp_many  bp2   bsub5 )  cp2) ->
     infer_v T5 Gamma5 (V_constr ctor5 vp5) (T_refined_type zp  (tsubst_bp_many  bp_5   bsub5 )  (C_eq (CE_val (V_var zp)) (CE_val (V_constr ctor5 vp5))))
with check_v : Theta -> Gamma -> vp -> tp -> Prop :=    (* defn check_v *)
 | check_v_v : forall (T5:Theta) (Gamma5:Gamma) (vp5:vp) (tp2 tp1:tp) (klist5:klist),
     infer_v T5 Gamma5 vp5 tp1 ->
     subtype T5  (add_vars_many  Gamma5   (cons klist5 nil) )  tp1 tp2 ->
     check_v T5 Gamma5 vp5 tp2.
(** definitions *)

(* defns typing_pat *)
Inductive infer_patp : Theta -> Gamma -> patp -> tp -> xp -> klist -> xlist -> Prop :=    (* defn infer_patp *)
 | infer_patm_typ : forall (xp_list:list xp) (T5:Theta) (Gamma5:Gamma) (zp:xp) (bp5:bp) (cp5:cp) (patp5:patp) (xp_5:xp) (klist5:klist),
      (  xp_5  = mk_fresh  Gamma5  )  ->
     check_patp T5 (G_cons Gamma5 xp_5 bp5  (subst_cp  (V_var xp_5)   zp   cp5  ) ) patp5 (T_refined_type zp bp5 cp5) xp_5 klist5  xp_list  ->
     infer_patp T5 Gamma5 (Pp_typ (T_refined_type zp bp5 cp5) patp5) (T_refined_type zp bp5 cp5) xp_5  (cons (XBC_triple  xp_5   bp5    (subst_cp  (V_var xp_5)   zp   cp5  )  ) ( klist5 ))   xp_list 
with check_patms : Theta -> Gamma -> list patp -> list bp -> klist -> list xp -> Prop :=    (* defn check_patms *)
 | check_patms_nil : forall (T5:Theta) (Gamma5:Gamma),
     check_patms T5 Gamma5 nil nil  ( nil )  nil
 | check_patms_cons : forall (patp_bp_xp_list:list (patp*bp*xp)) (T5:Theta) (Gamma5:Gamma) (patp_5:patp) (bp_5:bp) (klist_5 klist2:klist) (xp_5:xp) (xlist5:xlist),
     check_patp T5 Gamma5 patp_5 (T_refined_type VIndex bp_5 C_true) xp_5 klist_5 xlist5 ->
     check_patms T5  (add_vars_many  Gamma5   (cons klist_5 nil) )  (map (fun (pat_:(patp*bp*xp)) => match pat_ with (patp_,bp_,xp_) => patp_ end ) patp_bp_xp_list) (map (fun (pat_:(patp*bp*xp)) => match pat_ with (patp_,bp_,xp_) => bp_ end ) patp_bp_xp_list) klist2 (map (fun (pat_:(patp*bp*xp)) => match pat_ with (patp_,bp_,xp_) => xp_ end ) patp_bp_xp_list) ->
     check_patms T5 Gamma5 ((app (cons patp_5 nil) (app (map (fun (pat_:(patp*bp*xp)) => match pat_ with (patp_,bp_,xp_) => patp_ end ) patp_bp_xp_list) nil))) ((app (cons bp_5 nil) (app (map (fun (pat_:(patp*bp*xp)) => match pat_ with (patp_,bp_,xp_) => bp_ end ) patp_bp_xp_list) nil)))  (  klist_5  ++  klist2 )  ((app (cons xp_5 nil) (app (map (fun (pat_:(patp*bp*xp)) => match pat_ with (patp_,bp_,xp_) => xp_ end ) patp_bp_xp_list) nil)))
with check_patp : Theta -> Gamma -> patp -> tp -> xp -> klist -> xlist -> Prop :=    (* defn check_patp *)
 | check_patm_wild : forall (T5:Theta) (Gamma5:Gamma) (zp:xp) (bp5:bp) (cp5:cp) (xp5:xp),
     check_patp T5 Gamma5 Pp_wild (T_refined_type zp bp5 cp5) xp5  ( nil )   nil 
 | check_patm_id : forall (T5:Theta) (Gamma5:Gamma) (id5:id) (zp:xp) (bp5:bp) (cp5:cp) (xp5:xp),
     check_patp T5 Gamma5 (Pp_id id5) (T_refined_type zp bp5 cp5) xp5  ((XBC_triple  (VNamed id5)   bp5   (C_eq (CE_val (V_var xp5)) (CE_val (V_var (VNamed id5)))) ) :: nil)   (cons (VNamed id5) nil) 
 | check_patm_lit : forall (T5:Theta) (Gamma5:Gamma) (lit5:lit) (zp:xp) (bp5:bp) (cp5:cp) (xp1 xp2:xp),
      (  xp2  = mk_fresh  Gamma5  )  ->
     check_patp T5 Gamma5 (Pp_lit lit5) (T_refined_type zp bp5 cp5) xp1  ((XBC_triple  xp2   bp5   (C_eq (CE_val (V_var xp1)) (CE_val (V_lit lit5))) ) :: nil)   (cons xp1 nil) 
 | check_patm_ctor : forall (patp_list:list patp) (T5:Theta) (Gamma5:Gamma) (id5:id) (tp2:tp) (xp2:xp) (bp5:bp) (cp5:cp) (zp:xp) (vp5:vp) (klist5:klist) (xlist5:xlist) (tp1:tp),
      (Some ( tp1 , (T_refined_type zp bp5 cp5) ) = lookup_constr_union_type  T5   id5 )  ->
      (  xp2  = mk_fresh  Gamma5  )  ->
     check_patp T5 (G_cons Gamma5 xp2 bp5  (subst_cp  (V_var xp2)   zp   cp5  ) ) (Pp_tup patp_list) (T_refined_type zp bp5 cp5) xp2 klist5 xlist5 ->
      (Some  vp5  = mk_ctor_v  id5   xlist5 )  ->
     subtype T5 Gamma5 tp2 tp1 ->
     check_patp T5 Gamma5 (Pp_app id5 patp_list) tp2 xp2  (cons (XBC_triple  xp2   bp5   (C_conj  (subst_cp  (V_var xp2)   zp   cp5  )  (C_eq (CE_val (V_var xp2)) (CE_val vp5))) ) ( klist5 ))  xlist5
 | check_patm_ctor_single : forall (T5:Theta) (Gamma5:Gamma) (id5:id) (patp5:patp) (tp2:tp) (xp2:xp) (bp5:bp) (cp5:cp) (zp:xp) (vp5:vp) (klist5:klist) (xlist5:xlist) (tp1:tp),
      (Some ( tp1 , (T_refined_type zp bp5 cp5) ) = lookup_constr_union_type  T5   id5 )  ->
      (  xp2  = mk_fresh  Gamma5  )  ->
     check_patp T5 (G_cons Gamma5 xp2 bp5  (subst_cp  (V_var xp2)   zp   cp5  ) ) patp5 (T_refined_type zp bp5 cp5) xp2 klist5 xlist5 ->
      (Some  vp5  = mk_ctor_v  id5   xlist5 )  ->
     subtype T5 Gamma5 tp2 tp1 ->
     check_patp T5 Gamma5 (Pp_app id5 (cons patp5 nil)) tp2 xp2  (cons (XBC_triple  xp2   bp5   (C_conj  (subst_cp  (V_var xp2)   zp   cp5  )  (C_eq (CE_val (V_var xp2)) (CE_val vp5))) ) ( klist5 ))  xlist5
 | check_patm_tuple : forall (patp_bp_xp_list:list (patp*bp*xp)) (T5:Theta) (Gamma5:Gamma) (zp:xp) (cp5:cp) (xp_5:xp) (klist1 klist2:klist),
      ((  (map (fun (pat_:(patp*bp*xp)) => match pat_ with (patp_,bp_,xp_) => xp_ end ) patp_bp_xp_list)  ,  klist1  ) = mk_proj_vars  xp_5   (map (fun (pat_:(patp*bp*xp)) => match pat_ with (patp_,bp_,xp_) => bp_ end ) patp_bp_xp_list)  )  ->
     check_patms T5  (add_vars_many  Gamma5   (cons klist1 nil) )  (map (fun (pat_:(patp*bp*xp)) => match pat_ with (patp_,bp_,xp_) => patp_ end ) patp_bp_xp_list) (map (fun (pat_:(patp*bp*xp)) => match pat_ with (patp_,bp_,xp_) => bp_ end ) patp_bp_xp_list) klist2 (map (fun (pat_:(patp*bp*xp)) => match pat_ with (patp_,bp_,xp_) => xp_ end ) patp_bp_xp_list) ->
     check_patp T5 Gamma5 (Pp_tup (map (fun (pat_:(patp*bp*xp)) => match pat_ with (patp_,bp_,xp_) => patp_ end ) patp_bp_xp_list)) (T_refined_type zp (B_tuple (map (fun (pat_:(patp*bp*xp)) => match pat_ with (patp_,bp_,xp_) => bp_ end ) patp_bp_xp_list)) cp5) xp_5  (  klist1  ++  klist2 )   (cons xp_5 nil) 
 | check_patm_typ : forall (T5:Theta) (Gamma5:Gamma) (tp1:tp) (patp5:patp) (tp2:tp) (xp5:xp) (klist5:klist) (xlist5:xlist),
     check_patp T5 Gamma5 patp5 tp1 xp5 klist5 xlist5 ->
     subtype T5  (add_vars_many  Gamma5   (cons klist5 nil) )  tp1 tp2 ->
     check_patp T5 Gamma5 (Pp_typ tp1 patp5) tp2 xp5 klist5 xlist5.
(** definitions *)

(* defns typing_lexp *)
Inductive infer_lexp : Theta -> Gamma -> Delta -> lexpp -> tp -> Delta -> Prop :=    (* defn infer_lexp *)
 | infer_lexp_var_bound : forall (T5:Theta) (Gamma5:Gamma) (D5:Delta) (up5:up) (tp5:tp),
      ((Some  tp5 ) = lookup_mvar  D5   up5 )  ->
     infer_lexp T5 Gamma5 D5 (LEXPp_mvar up5) tp5 D5
 | infer_lexp_cast_not_bound : forall (T5:Theta) (Gamma5:Gamma) (D5:Delta) (tp5:tp) (up5:up),
      ( None = lookup_mvar  D5   up5  )  ->
     infer_lexp T5 Gamma5 D5 (LEXPp_cast tp5 up5) tp5  (add_mvar  D5  ( up5 , tp5 )) 
 | infer_lexp_cast_bound : forall (T5:Theta) (Gamma5:Gamma) (D5:Delta) (tp2:tp) (up5:up) (tp1:tp),
      ((Some  tp1 ) = lookup_mvar  D5   up5 )  ->
     subtype T5 Gamma5 tp2 tp1 ->
     infer_lexp T5 Gamma5 D5 (LEXPp_cast tp2 up5) tp2  (update_mvar  D5  ( up5 , tp2 )) 
 | infer_lexp_tup : forall (lexpp_bp_cp_p_zp_list:list (lexpp*bp*cp*nat*xp)) (T5:Theta) (Gamma5:Gamma) (D5:Delta) (zp:xp) (D':Delta),
     infer_lexps_ T5 Gamma5 D5 (map (fun (pat_:(lexpp*bp*cp*nat*xp)) => match pat_ with (lexpp_,bp_,cp_,p_,zp_) => lexpp_ end ) lexpp_bp_cp_p_zp_list) (map (fun (pat_:(lexpp*bp*cp*nat*xp)) => match pat_ with (lexpp_,bp_,cp_,p_,zp_) => (T_refined_type zp_ bp_ cp_) end ) lexpp_bp_cp_p_zp_list) D' ->
     infer_lexp T5 Gamma5 D5 (LEXPp_tup (map (fun (pat_:(lexpp*bp*cp*nat*xp)) => match pat_ with (lexpp_,bp_,cp_,p_,zp_) => lexpp_ end ) lexpp_bp_cp_p_zp_list)) (T_refined_type VIndex (B_tuple (map (fun (pat_:(lexpp*bp*cp*nat*xp)) => match pat_ with (lexpp_,bp_,cp_,p_,zp_) => bp_ end ) lexpp_bp_cp_p_zp_list)) (C_conj_many (map (fun (pat_:(lexpp*bp*cp*nat*xp)) => match pat_ with (lexpp_,bp_,cp_,p_,zp_) =>  (subst_cp   (V_proj p_ (V_var zp))    zp_   cp_  )  end ) lexpp_bp_cp_p_zp_list))) D'
 | infer_lexp_field : forall (T5:Theta) (Gamma5:Gamma) (D5:Delta) (lexpp5:lexpp) (id5:id) (bp5:bp) (D':Delta) (tp1 tp2:tp),
      (Some ( bp5 , tp1 ) = lookup_field_record_type  T5   id5 )  ->
     infer_lexp T5 Gamma5 D5 lexpp5 tp2 D' ->
     subtype T5 Gamma5 tp2 tp1 ->
     infer_lexp T5 Gamma5 D5 (LEXPp_field lexpp5 id5) (T_refined_type VIndex bp5 C_true) D'
with infer_lexps_ : Theta -> Gamma -> Delta -> list lexpp -> list tp -> Delta -> Prop :=    (* defn infer_lexps_ *)
 | infer_lexps_nil : forall (T5:Theta) (Gamma5:Gamma) (D5:Delta),
     infer_lexps_ T5 Gamma5 D5 nil nil D5
 | infer_lexps_cons : forall (lexpp_tp_list:list (lexpp*tp)) (T5:Theta) (Gamma5:Gamma) (D5:Delta) (lexpp_5:lexpp) (tp_5:tp) (D'' D':Delta),
     infer_lexp T5 Gamma5 D5 lexpp_5 tp_5 D' ->
     infer_lexps_ T5 Gamma5 D' (map (fun (pat_:(lexpp*tp)) => match pat_ with (lexpp_,tp_) => lexpp_ end ) lexpp_tp_list) (map (fun (pat_:(lexpp*tp)) => match pat_ with (lexpp_,tp_) => tp_ end ) lexpp_tp_list) D'' ->
     infer_lexps_ T5 Gamma5 D5 ((app (cons lexpp_5 nil) (app (map (fun (pat_:(lexpp*tp)) => match pat_ with (lexpp_,tp_) => lexpp_ end ) lexpp_tp_list) nil))) ((app (cons tp_5 nil) (app (map (fun (pat_:(lexpp*tp)) => match pat_ with (lexpp_,tp_) => tp_ end ) lexpp_tp_list) nil))) D''
with check_lexps_ : Theta -> Gamma -> Delta -> list lexpp -> list bp -> Delta -> Prop :=    (* defn check_lexps_ *)
 | check_lexps_nil : forall (T5:Theta) (Gamma5:Gamma) (D5:Delta),
     check_lexps_ T5 Gamma5 D5 nil nil D5
 | check_lexps_cons : forall (lexpp_bp_list:list (lexpp*bp)) (T5:Theta) (Gamma5:Gamma) (D5:Delta) (lexpp_5:lexpp) (bp_5:bp) (D'' D':Delta),
     check_lexp T5 Gamma5 D5 lexpp_5 (T_refined_type VIndex bp_5 C_true) D' ->
     check_lexps_ T5 Gamma5 D' (map (fun (pat_:(lexpp*bp)) => match pat_ with (lexpp_,bp_) => lexpp_ end ) lexpp_bp_list) (map (fun (pat_:(lexpp*bp)) => match pat_ with (lexpp_,bp_) => bp_ end ) lexpp_bp_list) D'' ->
     check_lexps_ T5 Gamma5 D5 ((app (cons lexpp_5 nil) (app (map (fun (pat_:(lexpp*bp)) => match pat_ with (lexpp_,bp_) => lexpp_ end ) lexpp_bp_list) nil))) ((app (cons bp_5 nil) (app (map (fun (pat_:(lexpp*bp)) => match pat_ with (lexpp_,bp_) => bp_ end ) lexpp_bp_list) nil))) D''
with check_lexp : Theta -> Gamma -> Delta -> lexpp -> tp -> Delta -> Prop :=    (* defn check_lexp *)
 | check_lexp_var_not_bound : forall (T5:Theta) (Gamma5:Gamma) (D5:Delta) (up5:up) (tp5:tp),
      ( None = lookup_mvar  D5   up5  )  ->
     check_lexp T5 Gamma5 D5 (LEXPp_mvar up5) tp5  (add_mvar  D5  ( up5 , tp5 )) 
 | check_lexp_subtype_infer : forall (T5:Theta) (Gamma5:Gamma) (D5:Delta) (lexpp5:lexpp) (tp1:tp) (D':Delta) (tp2:tp),
     infer_lexp T5 Gamma5 D5 lexpp5 tp2 D' ->
     subtype T5 Gamma5 tp1 tp2 ->
     check_lexp T5 Gamma5 D5 lexpp5 tp1 D'
 | check_lexp_tuple : forall (lexpp_bp_list:list (lexpp*bp)) (T5:Theta) (Gamma5:Gamma) (D5:Delta) (zp:xp) (cp5:cp) (D':Delta),
     check_lexps_ T5 Gamma5 D5 (map (fun (pat_:(lexpp*bp)) => match pat_ with (lexpp_,bp_) => lexpp_ end ) lexpp_bp_list) (map (fun (pat_:(lexpp*bp)) => match pat_ with (lexpp_,bp_) => bp_ end ) lexpp_bp_list) D' ->
     check_lexp T5 Gamma5 D5 (LEXPp_tup (map (fun (pat_:(lexpp*bp)) => match pat_ with (lexpp_,bp_) => lexpp_ end ) lexpp_bp_list)) (T_refined_type zp (B_tuple (map (fun (pat_:(lexpp*bp)) => match pat_ with (lexpp_,bp_) => bp_ end ) lexpp_bp_list)) cp5) D'.
(** definitions *)

(* defns typing_e *)
Inductive check_pexp : Theta -> Phi -> Gamma -> Delta -> pexpp -> tp -> tp -> Gamma -> Prop :=    (* defn check_pexp *)
 | check_pexp_exp : forall (xp_list:list xp) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (patp5:patp) (ep5:ep) (zp:xp) (bp5:bp) (cp5:cp) (tp5:tp) (xp_5:xp) (klist5:klist),
      (  xp_5  = mk_fresh  Gamma5  )  ->
     check_patp T5 (G_cons Gamma5 xp_5 bp5  (subst_cp  (V_var xp_5)   zp   cp5  ) ) patp5 (T_refined_type zp bp5 cp5) xp_5 klist5  xp_list  ->
     check_e T5 P5  (add_vars_many  (G_cons Gamma5 xp_5 bp5  (subst_cp  (V_var xp_5)   zp   cp5  ) )   (cons klist5 nil) )  D5 ep5 tp5 ->
     check_pexp T5 P5 Gamma5 D5 (PEXPp_exp patp5 ep5) (T_refined_type zp bp5 cp5) tp5  (add_vars_many  (G_cons Gamma5 xp_5 bp5  (subst_cp  (V_var xp_5)   zp   cp5  ) )   (cons klist5 nil) ) 
 | check_pexp_when : forall (xp_list:list xp) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (patp5:patp) (ep1 ep2:ep) (tp2 tp1:tp) (klist_5 klist2:klist) (xp_5:xp) (cp5:cp) (xp':xp),
      (  xp_5  = mk_fresh  Gamma5  )  ->
     check_patp T5 Gamma5 patp5 tp2 xp_5 klist_5  xp_list  ->
     infer_e T5 P5  (add_vars_many  Gamma5   (cons klist_5 nil) )  D5 ep1 (T_refined_type VIndex B_bool cp5) xp' klist2 ->
     check_e T5 P5  (add_vars_many    (add_vars_many  Gamma5   (cons klist_5 nil) )     (cons klist2 nil) )  D5 ep2 tp1 ->
     check_pexp T5 P5 Gamma5 D5 (PEXPp_when patp5 ep1 ep2) tp2 tp1  (add_vars_many    (add_vars_many  Gamma5   (cons klist_5 nil) )     (cons klist2 nil) ) 
with match_arg : Theta -> Gamma -> xp -> bp -> cp -> list ap -> ap -> bsub -> Prop :=    (* defn match_arg *)
 | match_arg_head : forall (ap_list:list ap) (T5:Theta) (Gamma5:Gamma) (zp2:xp) (bp2:bp) (cp2:cp) (xp1:xp) (bp1:bp) (cp1:cp) (zp3:xp) (bp3:bp) (cp3:cp) (bsub5:bsub),
      Some  bsub5  = unify_b   bp1   bp2  ->
     subtype T5 Gamma5 (T_refined_type zp2  (tsubst_bp_many  bp2   bsub5 )  cp2) (T_refined_type xp1  (tsubst_bp_many  bp1   bsub5 )  cp1) ->
     match_arg T5 Gamma5 zp2 bp2 cp2 ((app (cons (A_function xp1 bp1 cp1 (T_refined_type zp3 bp3 cp3)) nil) (app ap_list nil))) (A_function xp1 bp1 cp1 (T_refined_type zp3 bp3 cp3)) bsub5
 | match_arg_tail : forall (ap_list:list ap) (T5:Theta) (Gamma5:Gamma) (zp2:xp) (bp2:bp) (cp2:cp) (ap_5:ap) (xp1:xp) (bp1:bp) (cp1:cp) (zp3:xp) (bp3:bp) (cp3:cp) (bsub5:bsub),
     match_arg T5 Gamma5 zp2 bp2 cp2 ap_list (A_function xp1 bp1 cp1 (T_refined_type zp3 bp3 cp3)) bsub5 ->
     match_arg T5 Gamma5 zp2 bp2 cp2 ((app (cons ap_5 nil) (app ap_list nil))) (A_function xp1 bp1 cp1 (T_refined_type zp3 bp3 cp3)) bsub5
with infer_app : Theta -> Phi -> Gamma -> Delta -> list ap -> ep -> tp -> xp -> klist -> Prop :=    (* defn infer_app *)
 | infer_app_app_head : forall (ap_list:list ap) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (ep5:ep) (zp3:xp) (bp3:bp) (bsub5:bsub) (cp3:cp) (xp1 xp2 xp3:xp) (klist5:klist) (zp2:xp) (bp2:bp) (cp2:cp) (bp1:bp) (cp1:cp),
     infer_e T5 P5 Gamma5 D5 ep5 (T_refined_type zp2 bp2 cp2) xp2 klist5 ->
     match_arg T5  (add_vars_many  Gamma5   (cons klist5 nil) )  zp2 bp2 cp2 ap_list (A_function xp1 bp1 cp1 (T_refined_type zp3 bp3 cp3)) bsub5 ->
      (  xp3  = mk_fresh   (add_vars_many  Gamma5   (cons klist5 nil) )   )  ->
     infer_app T5 P5 Gamma5 D5 ap_list ep5 (T_refined_type zp3  (tsubst_bp_many  bp3   bsub5 )   (subst_cp  (V_var xp1)   xp2   cp3  ) ) xp3  (cons (XBC_triple  xp3    (tsubst_bp_many  bp3   bsub5 )     (subst_cp  (V_var xp1)   xp2     (subst_cp  (V_var xp3)   zp3   cp3  )    )  ) ( klist5 )) 
with infer_e_list : Theta -> Phi -> Gamma -> Delta -> list ep -> list tp -> list xp -> klist -> Prop :=    (* defn infer_e_list *)
 | infer_e_list_nil : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta),
     infer_e_list T5 P5 Gamma5 D5 nil nil nil  nil 
 | infer_e_list_cons : forall (ep_tp_xp_list:list (ep*tp*xp)) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (ep_5:ep) (tp_5:tp) (xp_5:xp) (klist1 klist2:klist),
     infer_e T5 P5 Gamma5 D5 ep_5 tp_5 xp_5 klist1 ->
     infer_e_list T5 P5  (add_vars_many  Gamma5   (cons klist1 nil) )  D5 (map (fun (pat_:(ep*tp*xp)) => match pat_ with (ep_,tp_,xp_) => ep_ end ) ep_tp_xp_list) (map (fun (pat_:(ep*tp*xp)) => match pat_ with (ep_,tp_,xp_) => tp_ end ) ep_tp_xp_list) (map (fun (pat_:(ep*tp*xp)) => match pat_ with (ep_,tp_,xp_) => xp_ end ) ep_tp_xp_list) klist2 ->
     infer_e_list T5 P5 Gamma5 D5 ((app (cons ep_5 nil) (app (map (fun (pat_:(ep*tp*xp)) => match pat_ with (ep_,tp_,xp_) => ep_ end ) ep_tp_xp_list) nil))) ((app (cons tp_5 nil) (app (map (fun (pat_:(ep*tp*xp)) => match pat_ with (ep_,tp_,xp_) => tp_ end ) ep_tp_xp_list) nil))) ((app (cons xp_5 nil) (app (map (fun (pat_:(ep*tp*xp)) => match pat_ with (ep_,tp_,xp_) => xp_ end ) ep_tp_xp_list) nil)))  (  klist1  ++  klist2 ) 
with letbind : Theta -> Phi -> Gamma -> Delta -> letbindp -> klist -> Prop :=    (* defn letbind *)
 | letbind_infer : forall (yp_list:list xp) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (patp5:patp) (ep5:ep) (klist1 klist2:klist) (tp5:tp) (xp1:xp),
     infer_e T5 P5 Gamma5 D5 ep5 tp5 xp1 klist1 ->
     check_patp T5  (add_vars_many  Gamma5   (cons klist1 nil) )  patp5 tp5 xp1 klist2  yp_list  ->
      (check_vars  Gamma5   yp_list )  ->
     letbind T5 P5 Gamma5 D5 (LBp_val patp5 ep5)  (  klist1  ++  klist2 ) 
 | letbind_check : forall (xp_list:list xp) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (zp:xp) (bp5:bp) (cp5:cp) (patp5:patp) (ep5:ep) (klist5:klist) (xp_5:xp),
     check_e T5 P5 Gamma5  DEmpty  ep5 (T_refined_type zp bp5 cp5) ->
      (  xp_5  = mk_fresh  Gamma5  )  ->
     check_patp T5 (G_cons Gamma5 xp_5 bp5  (subst_cp  (V_var xp_5)   zp   cp5  ) ) patp5 (T_refined_type zp bp5 cp5) xp_5 klist5  xp_list  ->
      (check_vars  Gamma5   xp_list )  ->
     letbind T5 P5 Gamma5 D5 (LBp_val (Pp_typ (T_refined_type zp bp5 cp5) patp5) ep5) klist5
with infer_e : Theta -> Phi -> Gamma -> Delta -> ep -> tp -> xp -> klist -> Prop :=    (* defn infer_e *)
 | infer_e_val : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (vp5:vp) (zp:xp) (bp5:bp) (cp5:cp) (xp5:xp),
      (  xp5  = mk_fresh  Gamma5  )  ->
     infer_v T5 Gamma5 vp5 (T_refined_type zp bp5 cp5) ->
     infer_e T5 P5 Gamma5 D5 (Ep_val vp5) (T_refined_type zp bp5 cp5) xp5  ((XBC_triple  xp5   bp5    (subst_cp  (V_var xp5)   zp   cp5  )  ) :: nil) 
 | infer_e_mvar : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (up5:up) (zp:xp) (bp5:bp) (cp5:cp) (xp5:xp),
      (  xp5  = mk_fresh  Gamma5  )  ->
      ((Some  (T_refined_type zp bp5 cp5) ) = lookup_mvar  D5   up5 )  ->
     infer_e T5 P5 Gamma5 D5 (Ep_mvar up5) (T_refined_type zp bp5 cp5) xp5  ((XBC_triple  xp5   bp5    (subst_cp  (V_var xp5)   zp   cp5  )  ) :: nil) 
 | infer_e_sizeof : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (cep5:cep) (xp5:xp),
      (  xp5  = mk_fresh  Gamma5  )  ->
     infer_e T5 P5 Gamma5 D5 (Ep_sizeof cep5) (T_refined_type VIndex B_int (C_eq (CE_val (V_var VIndex)) cep5)) xp5  ((XBC_triple  xp5   B_int   (C_eq (CE_val (V_var xp5)) cep5) ) :: nil) 
 | infer_e_constraint : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (cp5:cp) (xp5:xp),
      (  xp5  = mk_fresh  Gamma5  )  ->
     infer_e T5 P5 Gamma5 D5 (Ep_constraint cp5) (T_refined_type VIndex B_bool cp5) xp5  ((XBC_triple  xp5   B_bool   cp5 ) :: nil) 
 | infer_e_app : forall (ap_list:list ap) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (fp:xp) (ep5:ep) (tp1:tp) (xp1:xp) (klist5:klist),
      (Some  ap_list  = lookup_fun_type  T5   P5   fp  )  ->
     infer_app T5 P5 Gamma5 D5 ap_list ep5 tp1 xp1 klist5 ->
     infer_e T5 P5 Gamma5 D5 (Ep_app fp ep5) tp1 xp1 klist5
 | infer_e_tuple : forall (ep_bp_xp_tp_list:list (ep*bp*xp*tp)) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (xp_5:xp) (klist5:klist),
      (  xp_5  = mk_fresh   (add_vars_many  Gamma5   (cons klist5 nil) )   )  ->
     infer_e_list T5 P5 Gamma5 D5 (map (fun (pat_:(ep*bp*xp*tp)) => match pat_ with (ep_,bp_,xp_,tp_) => ep_ end ) ep_bp_xp_tp_list) (map (fun (pat_:(ep*bp*xp*tp)) => match pat_ with (ep_,bp_,xp_,tp_) => tp_ end ) ep_bp_xp_tp_list) (map (fun (pat_:(ep*bp*xp*tp)) => match pat_ with (ep_,bp_,xp_,tp_) => xp_ end ) ep_bp_xp_tp_list) klist5 ->
      ( (map (fun (pat_:(ep*bp*xp*tp)) => match pat_ with (ep_,bp_,xp_,tp_) => bp_ end ) ep_bp_xp_tp_list)  = b_of_many  (map (fun (pat_:(ep*bp*xp*tp)) => match pat_ with (ep_,bp_,xp_,tp_) => tp_ end ) ep_bp_xp_tp_list) )  ->
     infer_e T5 P5 Gamma5 D5 (Ep_tuple (map (fun (pat_:(ep*bp*xp*tp)) => match pat_ with (ep_,bp_,xp_,tp_) => ep_ end ) ep_bp_xp_tp_list)) (T_refined_type VIndex (B_tuple (map (fun (pat_:(ep*bp*xp*tp)) => match pat_ with (ep_,bp_,xp_,tp_) => bp_ end ) ep_bp_xp_tp_list)) (C_eq (CE_val (V_var VIndex)) (CE_val (V_tuple (map (fun (pat_:(ep*bp*xp*tp)) => match pat_ with (ep_,bp_,xp_,tp_) => (V_var xp_) end ) ep_bp_xp_tp_list))))) xp_5  (cons (XBC_triple  xp_5   (B_tuple (map (fun (pat_:(ep*bp*xp*tp)) => match pat_ with (ep_,bp_,xp_,tp_) => bp_ end ) ep_bp_xp_tp_list))   (C_eq (CE_val (V_var xp_5)) (CE_val (V_tuple (map (fun (pat_:(ep*bp*xp*tp)) => match pat_ with (ep_,bp_,xp_,tp_) => (V_var xp_) end ) ep_bp_xp_tp_list)))) ) ( klist5 )) 
 | infer_e_vec_concat : forall (ep_xp_klist_cp_list:list (ep*xp*klist*cp)) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (order5:order) (bp5:bp) (xp_5 zp:xp),
     (forall ep_ cp_ xp_ klist_, In (ep_,cp_,xp_,klist_) (map (fun (pat_: (ep*xp*klist*cp)) => match pat_ with (ep_,xp_,klist_,cp_) => (ep_,cp_,xp_,klist_) end) ep_xp_klist_cp_list) -> (infer_e T5 P5 Gamma5 D5 ep_ (T_refined_type zp (B_vec order5 bp5) cp_) xp_ klist_)) ->
      (  xp_5  = mk_fresh   (add_vars_many  Gamma5   (cons  (klist_concat ( (map (fun (pat_:(ep*xp*klist*cp)) => match pat_ with (ep_,xp_,klist_,cp_) => klist_ end ) ep_xp_klist_cp_list) ))  nil) )   )  ->
     infer_e T5 P5 Gamma5 D5 (Ep_concat (map (fun (pat_:(ep*xp*klist*cp)) => match pat_ with (ep_,xp_,klist_,cp_) => ep_ end ) ep_xp_klist_cp_list)) (T_refined_type VIndex (B_vec order5 bp5) (C_eq (CE_uop Len (CE_val (V_var VIndex))) (CE_many_plus (map (fun (pat_:(ep*xp*klist*cp)) => match pat_ with (ep_,xp_,klist_,cp_) => (CE_val (V_var xp_)) end ) ep_xp_klist_cp_list)))) xp_5  (cons (XBC_triple  xp_5   (B_vec order5 bp5)   (C_eq (CE_uop Len (CE_val (V_var xp_5))) (CE_many_plus (map (fun (pat_:(ep*xp*klist*cp)) => match pat_ with (ep_,xp_,klist_,cp_) => (CE_val (V_var xp_)) end ) ep_xp_klist_cp_list))) ) (  (klist_concat ( (map (fun (pat_:(ep*xp*klist*cp)) => match pat_ with (ep_,xp_,klist_,cp_) => klist_ end ) ep_xp_klist_cp_list) ))  )) 
 | infer_e_field_access : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (ep5:ep) (field5:field) (bp5:bp) (xp1 xp2:xp) (klist5:klist) (tp1 tp2:tp),
      (Some ( bp5 , tp1 ) = lookup_field_record_type  T5   field5 )  ->
     infer_e T5 P5 Gamma5 D5 ep5 tp2 xp1 klist5 ->
     subtype T5  (add_vars_many  Gamma5   (cons klist5 nil) )  tp2 tp1 ->
      (  xp2  = mk_fresh   (add_vars_many  Gamma5   (cons klist5 nil) )   )  ->
     infer_e T5 P5 Gamma5 D5 (Ep_field_access ep5 field5) (T_refined_type VIndex bp5 (C_eq (CE_field_access xp1 field5) (CE_val (V_var VIndex)))) xp2  (cons (XBC_triple  xp2   bp5   (C_eq (CE_field_access xp1 field5) (CE_val (V_var xp2))) ) ( klist5 )) 
 | infer_e_loop : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (loop5:loop) (ep1 ep2:ep) (xp_5:xp) (klist1:klist) (cp5:cp) (xp1:xp),
      (  xp_5  = mk_fresh   (add_vars_many  Gamma5   (cons klist1 nil) )   )  ->
     infer_e T5 P5 Gamma5 D5 ep1 (T_refined_type VIndex B_bool cp5) xp1 klist1 ->
     check_e T5 P5  (add_vars_many  Gamma5   (cons klist1 nil) )  D5 ep2 (T_refined_type VIndex B_unit C_true) ->
     infer_e T5 P5 Gamma5 D5 (Ep_loop loop5 ep1 ep2) (T_refined_type VIndex B_unit C_true) xp_5  ((XBC_triple  xp_5   B_unit   C_true ) :: nil) 
 | infer_e_record_update : forall (field_ep_bp_list:list (field*ep*bp)) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (ep_5:ep) (zp:xp) (bp_5:bp) (cp5:cp) (xp5:xp) (klist5:klist) (Gamma':Gamma),
     infer_e T5 P5 Gamma5 D5 ep_5 (T_refined_type zp bp_5 cp5) xp5 klist5 ->
      ((Some  (map (fun (pat_:(field*ep*bp)) => match pat_ with (field_,ep_,bp_) => bp_ end ) field_ep_bp_list) ) = lookup_types_for  bp_5   (map (fun (pat_:(field*ep*bp)) => match pat_ with (field_,ep_,bp_) => field_ end ) field_ep_bp_list) )  ->
     check_e_list T5 P5  (add_vars_many  Gamma5   (cons klist5 nil) )  D5 (map (fun (pat_:(field*ep*bp)) => match pat_ with (field_,ep_,bp_) => ep_ end ) field_ep_bp_list) (map (fun (pat_:(field*ep*bp)) => match pat_ with (field_,ep_,bp_) => (T_refined_type VIndex bp_ C_true) end ) field_ep_bp_list) Gamma' ->
     infer_e T5 P5 Gamma5 D5 (Ep_record_update ep_5 (map (fun (pat_:(field*ep*bp)) => match pat_ with (field_,ep_,bp_) => (field_,ep_) end ) field_ep_bp_list)) (T_refined_type zp bp_5 cp5) xp5  (cons (XBC_triple  xp5   bp_5    (subst_cp  (V_var xp5)   zp   cp5  )  ) ( klist5 )) 
with typing_lexp : Theta -> Phi -> Gamma -> Delta -> lexpp -> ep -> Delta -> klist -> Prop :=    (* defn typing_lexp *)
 | typing_lexp_mvar_not_bound : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (up5:up) (ep5:ep) (tp5:tp) (klist5:klist) (xp5:xp),
      ( None = lookup_mvar  D5   up5  )  ->
     infer_e T5 P5 Gamma5 D5 ep5 tp5 xp5 klist5 ->
     typing_lexp T5 P5 Gamma5 D5 (LEXPp_mvar up5) ep5  (add_mvar  D5  ( up5 , tp5 ))  klist5
 | typing_lexp_mvar_bound : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (up5:up) (ep5:ep) (tp5:tp),
      ((Some  tp5 ) = lookup_mvar  D5   up5 )  ->
     check_e T5 P5 Gamma5 D5 ep5 tp5 ->
     typing_lexp T5 P5 Gamma5 D5 (LEXPp_mvar up5) ep5 D5  ( nil ) 
 | typing_lexp_cast_not_bound : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (tp5:tp) (up5:up) (ep5:ep),
      ( None = lookup_mvar  D5   up5  )  ->
     check_e T5 P5 Gamma5 D5 ep5 tp5 ->
     typing_lexp T5 P5 Gamma5 D5 (LEXPp_cast tp5 up5) ep5  (add_mvar  D5  ( up5 , tp5 ))   ( nil ) 
 | typing_lexp_cast_bound : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (tp2:tp) (up5:up) (ep5:ep) (tp1:tp),
      ((Some  tp1 ) = lookup_mvar  D5   up5 )  ->
     subtype T5 Gamma5 tp2 tp1 ->
     check_e T5 P5 Gamma5 D5 ep5 tp2 ->
     typing_lexp T5 P5 Gamma5 D5 (LEXPp_cast tp2 up5) ep5  (update_mvar  D5  ( up5 , tp2 ))   ( nil ) 
 | typing_lexp_field : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (up5:up) (id5:id) (ep5:ep) (tp1 tp2 tp_5:tp),
      (Some ( tp1 , tp2 ) = lookup_field_and_record_type  T5   up5 )  ->
      ((Some  tp_5 ) = lookup_mvar  D5   up5 )  ->
     subtype T5 Gamma5 tp_5 tp2 ->
     check_e T5 P5 Gamma5 D5 ep5 tp1 ->
     typing_lexp T5 P5 Gamma5 D5 (LEXPp_field (LEXPp_mvar up5) id5) ep5 D5  ( nil ) 
 | typing_lexp_tuple_single : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (lexpp5:lexpp) (ep5:ep) (klist5:klist) (D':Delta),
     typing_lexp T5 P5 Gamma5 D5 lexpp5 ep5 D' klist5 ->
     typing_lexp T5 P5 Gamma5 D5 (LEXPp_tup (cons lexpp5 nil)) (Ep_tuple (cons ep5 nil)) D5 klist5
 | typing_lexp_tuple_cons : forall (lexpp_ep_list:list (lexpp*ep)) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (lexpp_5:lexpp) (ep_5:ep) (D'':Delta) (klist1 klist2:klist) (D':Delta),
     typing_lexp T5 P5 Gamma5 D5 lexpp_5 ep_5 D' klist1 ->
     typing_lexp T5 P5 Gamma5 D' (LEXPp_tup (map (fun (pat_:(lexpp*ep)) => match pat_ with (lexpp_,ep_) => lexpp_ end ) lexpp_ep_list)) (Ep_tuple (map (fun (pat_:(lexpp*ep)) => match pat_ with (lexpp_,ep_) => ep_ end ) lexpp_ep_list)) D'' klist2 ->
     typing_lexp T5 P5 Gamma5 D5 (LEXPp_tup ((app (cons lexpp_5 nil) (app (map (fun (pat_:(lexpp*ep)) => match pat_ with (lexpp_,ep_) => lexpp_ end ) lexpp_ep_list) nil)))) (Ep_tuple ((app (cons ep_5 nil) (app (map (fun (pat_:(lexpp*ep)) => match pat_ with (lexpp_,ep_) => ep_ end ) lexpp_ep_list) nil)))) D''  (  klist1  ++  klist2 ) 
with check_e_list : Theta -> Phi -> Gamma -> Delta -> list ep -> list tp -> Gamma -> Prop :=    (* defn check_e_list *)
 | check_e_list_nil : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta),
     check_e_list T5 P5 Gamma5 D5 nil nil Gamma5
 | check_e_list_cons : forall (ep_tp_list:list (ep*tp)) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (ep_5:ep) (tp_5:tp) (Gamma'':Gamma),
     check_e T5 P5 Gamma5 D5 ep_5 tp_5 ->
     check_e_list T5 P5 Gamma5 D5 (map (fun (pat_:(ep*tp)) => match pat_ with (ep_,tp_) => ep_ end ) ep_tp_list) (map (fun (pat_:(ep*tp)) => match pat_ with (ep_,tp_) => tp_ end ) ep_tp_list) Gamma'' ->
     check_e_list T5 P5 Gamma5 D5 ((app (cons ep_5 nil) (app (map (fun (pat_:(ep*tp)) => match pat_ with (ep_,tp_) => ep_ end ) ep_tp_list) nil))) ((app (cons tp_5 nil) (app (map (fun (pat_:(ep*tp)) => match pat_ with (ep_,tp_) => tp_ end ) ep_tp_list) nil))) Gamma''
with check_e : Theta -> Phi -> Gamma -> Delta -> ep -> tp -> Prop :=    (* defn check_e *)
 | check_e_return : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (ep5:ep) (tp2 tp1:tp),
      (Some  tp1  = lookup_return  Gamma5 )  ->
     check_e T5 P5 Gamma5 D5 ep5 tp1 ->
     check_e T5 P5 Gamma5 D5 (Ep_return ep5) tp2
 | check_e_exit : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (ep5:ep) (tp5:tp),
     check_e T5 P5 Gamma5 D5 ep5 (T_refined_type VIndex B_unit C_true) ->
     check_e T5 P5 Gamma5 D5 (Ep_exit ep5) tp5
 | check_e_if : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (ep_5 ep1 ep2:ep) (zp:xp) (bp5:bp) (cp_5:cp) (zp3:xp) (cp1:cp) (xp_5:xp) (klist5:klist) (xp3:xp),
     infer_e T5 P5 Gamma5 D5 ep_5 (T_refined_type zp3 B_bool cp1) xp_5 klist5 ->
      (  xp3  = mk_fresh   (add_vars_many  Gamma5   (cons klist5 nil) )   )  ->
     check_e T5 P5  (add_vars_many  Gamma5   (cons  (klist_concat ( (cons klist5 nil) ))  nil) )  D5 ep1 (T_refined_type zp bp5 (C_imp (C_eq (CE_val (V_var xp_5)) (CE_val (V_lit L_true))) cp_5)) ->
     check_e T5 P5  (add_vars_many  Gamma5   (cons  (klist_concat ( (cons klist5 nil) ))  nil) )  D5 ep2 (T_refined_type zp bp5 (C_imp (C_eq (CE_val (V_var xp_5)) (CE_val (V_lit L_false))) cp_5)) ->
     check_e T5 P5 Gamma5 D5 (Ep_if ep_5 ep1 ep2) (T_refined_type zp bp5 cp_5)
 | check_e_let : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (patp5:patp) (ep1 ep2:ep) (tp5:tp) (klist5:klist),
     letbind T5 P5 Gamma5 D5 (LBp_val patp5 ep1) klist5 ->
     check_e T5 P5  (add_vars_many  Gamma5   (cons klist5 nil) )  D5 ep2 tp5 ->
     check_e T5 P5 Gamma5 D5 (Ep_let (LBp_val patp5 ep1) ep2) tp5
 | check_e_case : forall (patp_ep_Gamma_list:list (patp*ep*Gamma)) (T5:Theta) (P5:Phi) (Gamma_5:Gamma) (D5:Delta) (ep_5:ep) (zp:xp) (bp5:bp) (cp5:cp) (tp5:tp) (xp5:xp) (klist1:klist),
     infer_e T5 P5 Gamma_5 D5 ep_5 tp5 xp5 klist1 ->
     (forall patp_ ep_ Gamma_, In (patp_,ep_,Gamma_) (map (fun (pat_: (patp*ep*Gamma)) => match pat_ with (patp_,ep_,Gamma_) => (patp_,ep_,Gamma_) end) patp_ep_Gamma_list) -> (check_pexp T5 P5  (add_vars_many  Gamma_5   (cons klist1 nil) )  D5 (PEXPp_exp patp_ ep_) tp5 (T_refined_type zp bp5 cp5) Gamma_)) ->
     check_e T5 P5 Gamma_5 D5 (Ep_case ep_5 (map (fun (pat_:(patp*ep*Gamma)) => match pat_ with (patp_,ep_,Gamma_) => (PEXPp_exp patp_ ep_) end ) patp_ep_Gamma_list)) (T_refined_type zp bp5 cp5)
 | check_e_assign : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (lexpp5:lexpp) (ep1 ep2:ep) (zp:xp) (bp5:bp) (cp5:cp) (D':Delta) (klist5:klist),
     typing_lexp T5 P5 Gamma5 D5 lexpp5 ep1 D' klist5 ->
     check_e T5 P5  (add_vars_many  Gamma5   (cons klist5 nil) )  D' ep2 (T_refined_type zp bp5 cp5) ->
     check_e T5 P5 Gamma5 D5 (Ep_assign lexpp5 ep1 ep2) (T_refined_type zp bp5 cp5)
 | check_e_seq_single : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (ep5:ep) (tp5:tp),
     check_e T5 P5 Gamma5 D5 ep5 tp5 ->
     check_e T5 P5 Gamma5 D5 (Ep_block (cons ep5 nil)) tp5
 | check_e_seq_cons : forall (ep_list:list ep) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (ep_5:ep) (tp5:tp),
     check_e T5 P5 Gamma5 D5 ep_5 (T_refined_type VIndex B_unit C_true) ->
     check_e T5 P5 Gamma5 D5 (Ep_block ep_list) tp5 ->
     check_e T5 P5 Gamma5 D5 (Ep_block ((app (cons ep_5 nil) (app ep_list nil)))) tp5
 | check_e_record : forall (field_ep_field'_bp_list:list (field*ep*field*bp)) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (zp:xp) (bp_5:bp) (cp_5 cp2:cp) (Gamma':Gamma) (zp2:xp),
      (Some  (T_refined_type VIndex (B_record (map (fun (pat_:(field*ep*field*bp)) => match pat_ with (field_,ep_,field'_,bp_) => (field'_,bp_) end ) field_ep_field'_bp_list)) cp2)  = lookup_fields  T5   (map (fun (pat_:(field*ep*field*bp)) => match pat_ with (field_,ep_,field'_,bp_) => field_ end ) field_ep_field'_bp_list)  )  ->
     check_e_list T5 P5 Gamma5 D5 (map (fun (pat_:(field*ep*field*bp)) => match pat_ with (field_,ep_,field'_,bp_) => ep_ end ) field_ep_field'_bp_list) (map (fun (pat_:(field*ep*field*bp)) => match pat_ with (field_,ep_,field'_,bp_) => (T_refined_type VIndex bp_ C_true) end ) field_ep_field'_bp_list) Gamma' ->
     subtype T5 Gamma5 (T_refined_type zp bp_5 cp_5) (T_refined_type zp2 (B_record (map (fun (pat_:(field*ep*field*bp)) => match pat_ with (field_,ep_,field'_,bp_) => (field_,bp_) end ) field_ep_field'_bp_list)) cp2) ->
     check_e T5 P5 Gamma5 D5 (Ep_record (map (fun (pat_:(field*ep*field*bp)) => match pat_ with (field_,ep_,field'_,bp_) => (field_,ep_) end ) field_ep_field'_bp_list)) (T_refined_type zp bp_5 cp_5)
 | check_e_subtype : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (D5:Delta) (ep5:ep) (tp2 tp1:tp) (xp5:xp) (klist5:klist),
     infer_e T5 P5 Gamma5 D5 ep5 tp1 xp5 klist5 ->
     subtype T5  (add_vars_many  Gamma5   (cons klist5 nil) )  tp1 tp2 ->
     check_e T5 P5 Gamma5 D5 ep5 tp2.
(** definitions *)

(* defns def_checking *)
Inductive check_funcls : Theta -> Phi -> Gamma -> list funclp -> xp -> bp -> cp -> tp -> Phi -> Gamma -> Prop :=    (* defn check_funcls *)
 | check_funclsnil : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (xp5:xp) (bp5:bp) (cp5:cp) (tp2:tp),
     check_funcls T5 P5 Gamma5 nil xp5 bp5 cp5 tp2 P5 Gamma5
 | check_funclscons : forall (funclp_list:list funclp) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (id5:id) (pexpp5:pexpp) (xp_5:xp) (bp5:bp) (cp5:cp) (tp2:tp) (P''':Phi) (xp2:xp) (Gamma' Gamma'':Gamma) (P'':Phi) (Gamma''':Gamma),
      (  xp2  = mk_fresh  Gamma5  )  ->
      ( Gamma'  = add_return  Gamma'   tp2 )  ->
     check_pexp T5 P5 Gamma'  DEmpty   (subst_pexpp  (V_var xp2)   xp_5   pexpp5  )  (T_refined_type VIndex bp5  (subst_cp  (V_var VIndex)   xp_5   cp5  ) )  (subst_tp   (V_var xp2)   xp_5   tp2 )  Gamma'' ->
      P''  = add_fun_all  P5  (A_function  xp_5   bp5   cp5   tp2 )  (cons (FCLp_funcl id5 pexpp5) nil)  ->
     check_funcls T5 P'' Gamma5 funclp_list xp_5 bp5 cp5 tp2 P''' Gamma''' ->
     check_funcls T5 P5 Gamma5 ((app (cons (FCLp_funcl id5 pexpp5) nil) (app funclp_list nil))) xp_5 bp5 cp5 tp2 P''' Gamma5
with check_def : Theta -> Phi -> Gamma -> defp -> Theta -> Phi -> Gamma -> Prop :=    (* defn check_def *)
 | check_def_fundef : forall (funclp_list:list funclp) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (xp5:xp) (bp5:bp) (cp5:cp) (tp2:tp) (P':Phi) (Gamma':Gamma),
     check_funcls T5 P5 Gamma5 funclp_list xp5 bp5 cp5 tp2 P' Gamma' ->
     check_def T5 P5 Gamma5 (DEFp_fundef (A_function xp5 bp5 cp5 tp2) funclp_list) T5 P' Gamma'
 | check_def_let : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (patp5:patp) (ep5:ep) (klist5:klist),
     letbind T5 P5 Gamma5  DEmpty  (LBp_val patp5 ep5) klist5 ->
     check_def T5 P5 Gamma5 (DEFp_val (LBp_val patp5 ep5)) T5 P5  (add_vars_many  Gamma5   (cons klist5 nil) ) 
 | check_def_val : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (id5:id) (ap5:ap),
      (None = lookup_fun  P5  (VNamed  id5 ) )  ->
     check_def T5 P5 Gamma5 (DEFp_spec id5 ap5) T5  (add_fun  P5  ( VNamed  id5 ,  ap5  , None))  Gamma5
 | check_def_overload : forall (id_list:list id) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (id_5:id),
     check_def T5 P5 Gamma5 (DEFp_overload id_5 id_list) T5  ( add_to_overload  P5  (VNamed  id_5 ) (List.map VNamed  id_list ) )  Gamma5
 | check_def_default : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (order5:order),
     check_def T5 P5 Gamma5 (DEFp_default order5)  (set_order  T5   order5 )  P5 Gamma5
 | check_def_typedef : forall (kp_bp_cp_list:list (xp*bp*cp)) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (id5:id) (tp5:tp),
     check_def T5 P5 Gamma5 (DEFp_typedef id5 kp_bp_cp_list tp5)  (add_type  T5  (VNamed  id5 )  tp5 )  P5 Gamma5
with check_defs : Theta -> Phi -> Gamma -> list defp -> Theta -> Phi -> Gamma -> Prop :=    (* defn check_defs *)
 | check_defs_nil : forall (T5:Theta) (P5:Phi) (Gamma5:Gamma) (defp5:defp) (T':Theta) (P':Phi) (Gamma':Gamma),
     check_def T5 P5 Gamma5 defp5 T' P' Gamma' ->
     check_defs T5 P5 Gamma5 (cons defp5 nil) T' P' Gamma'
 | check_defs_cons : forall (defp_list:list defp) (T5:Theta) (P5:Phi) (Gamma5:Gamma) (defp_5:defp) (T'':Theta) (P'':Phi) (Gamma'':Gamma) (T':Theta) (P':Phi) (Gamma':Gamma),
     check_def T5 P5 Gamma5 defp_5 T' P' Gamma' ->
     check_defs T' P' Gamma' defp_list T'' P'' Gamma'' ->
     check_defs T5 P5 Gamma5 ((app (cons defp_5 nil) (app defp_list nil))) T'' P'' Gamma''.


